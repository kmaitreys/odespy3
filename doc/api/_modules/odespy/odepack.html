
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>odespy.odepack &mdash; Odespy API 0.2 documentation</title>
    
    <link rel="stylesheet" href="../../_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Odespy API 0.2 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="../../_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Odespy API 0.2 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for odespy.odepack</h1><div class="highlight"><pre>
<span class="n">__author__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Liwei Wang, Univ. of Oslo&#39;</span><span class="p">]</span>

<span class="kn">from</span> <span class="nn">solvers</span> <span class="kn">import</span> <span class="n">Solver</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">inspect</span>

<span class="n">_parameters_Odepack</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>

    <span class="c"># Note that ODEPACK has its own convention for the</span>
    <span class="c"># arguments to the f and jac functions</span>

    <span class="n">f_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Fortran subroutine for f.</span>
<span class="s">This subroutine has the signature::</span>

<span class="s">        subroutine f_f77(neq,t,u,udot)</span>
<span class="s">  Cf2py intent(hide)   neq</span>
<span class="s">  Cf2py intent(out)    udot</span>
<span class="s">        integer neq</span>
<span class="s">        double precision t,u(neq),udot(neq)</span>
<span class="s">        udot = ...</span>
<span class="s">        return</span>
<span class="s">        end</span>

<span class="s">&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Fortran subroutine for jac.</span>
<span class="s">This subroutine has the signature::</span>

<span class="s">       subroutine jac_f77</span>
<span class="s">      1 (neq, t, u, ml, mu, pd, nrowpd)</span>
<span class="s"> Cf2py intent(hide) neq,ml,mu,nrowpd</span>
<span class="s"> Cf2py intent(out) pd</span>
<span class="s">       integer neq,ml,mu,nrowpd</span>
<span class="s">       double precision t,u,pd</span>
<span class="s">       dimension u(neq),pd(neq,neq)</span>
<span class="s">       pd = ...</span>
<span class="s">       return</span>
<span class="s">       end</span>

<span class="s">&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_banded</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Function for Jacobian in banded matrix form.</span>
<span class="s">Used in Lsode, Lsoda, Lsodar.</span>
<span class="s">``jac_banded(u,t,ml,mu)`` returns df/du as an</span>
<span class="s">array of size ``neq`` times ``ml+mu+1``.&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,ml,mu&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,ml,mu&#39;</span><span class="p">,</span>
        <span class="n">array_order</span><span class="o">=</span><span class="s">&#39;Fortran&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_banded_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Fortran subroutine for jac_banded.</span>
<span class="s">This subroutine has the signature::</span>

<span class="s">        subroutine jac_banded_f77</span>
<span class="s">       1  (neq,t,u,ml, mu,pd,nrowpd)</span>
<span class="s">  Cf2py intent(hide) neq,ml,mu,nrowpd</span>
<span class="s">  Cf2py intent(out) pd</span>
<span class="s">        integer neq,ml,mu,nrowpd</span>
<span class="s">        double precision t,u,pd</span>
<span class="s">        dimension u(neq),pd(nrowpd,neq)</span>
<span class="s">        pd = ...</span>
<span class="s">        return</span>
<span class="s">        end</span>

<span class="s">&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">g</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Callable object to define constraint functions.</span>
<span class="s">``g(u, t)`` returns a vector of the values of the constraints</span>
<span class="s">(left-hand sides in the constraint equations).</span>
<span class="s"> &#39;&#39;&#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;g_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">g_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Fortran subroutine for g.</span>
<span class="s">This subroutine has the signature::</span>

<span class="s">        subroutine g_f77(neq, t, u, ng, groot)</span>
<span class="s">  Cf2py intent(hide) neq</span>
<span class="s">  Cf2py optional, intent(hide) ng</span>
<span class="s">  Cf2py intent(in) t, u</span>
<span class="s">  Cf2py intent(out) groot</span>
<span class="s">        integer neq, ng</span>
<span class="s">        double precision t, u, groot</span>
<span class="s">        dimension u(neq), groot(ng)</span>
<span class="s">        groot = ...</span>
<span class="s">        return</span>
<span class="s">        end</span>

<span class="s">&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_column</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">A callable object to specify a column of the Jacobian.</span>
<span class="s">``jac(u,t,j,ia,ja)`` returns the j-th column of the</span>
<span class="s">Jacobian.&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,j&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,j&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;jac_column_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_column_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Fortran subroutine for jac_column.</span>
<span class="s">This subroutine has the signature::</span>

<span class="s">        subroutine jac_column_f77</span>
<span class="s">       1  (neq, t, u, j, ia, ja, pd)</span>
<span class="s">  Cf2py intent(hide) neq, ia, ja</span>
<span class="s">  Cf2py intent(out) pd</span>
<span class="s">        integer neq, j, ia, ja</span>
<span class="s">        double precision t, u, pd</span>
<span class="s">        dimension u(neq), pd(neq), ia(neq + 1), ja(*)</span>
<span class="s">        pd = ...</span>
<span class="s">        return</span>
<span class="s">        end</span>

<span class="s">&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="c"># parameters for linearly implicit ODE solvers: Lsodi, Lsoibt, Lsodis</span>
    <span class="n">res</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;User-supplied function to calculate the residual</span>
<span class="s">vector, defined by r =  g(u,t) - A(u,t) * s.</span>
<span class="s">Used in the linearly implicit solvers: Lsodi,</span>
<span class="s">Lsodis, Lsoibt. The ``res`` function has the</span>
<span class="s">signature ``res(u,t,s,ires)`` and returns</span>
<span class="s">the tuple ``(r,ires)``, where ``ires`` is an</span>
<span class="s">int. On input, ires indicates how ODEPACK would use</span>
<span class="s">the returned array &quot;r&quot;: ``ires=1`` means the full</span>
<span class="s">residual exactly, ``ires=2`` means that ``r`` is</span>
<span class="s">used only to compute the Jacobian dr/du by finite</span>
<span class="s">differences.</span>
<span class="s">``res`` should set the flag ``ires`` if it encounters</span>
<span class="s">a halt condition or illegal input. Otherwise, it</span>
<span class="s">should not be reset. On output, the value 1 or -1</span>
<span class="s">represents a normal return.</span>
<span class="s">&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,s,ires&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,s,ires&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;res_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">res_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Fortran subroutine for res.</span>
<span class="s">This subroutine has the signature::</span>

<span class="s">      subroutine res_f77(neq, t, u, s, r, ires)</span>
<span class="s"> Cf2py intent(hide) neq</span>
<span class="s"> Cf2py intent(out) r</span>
<span class="s"> Cf2py intent(in,out) ires</span>
<span class="s">      double precision t, u, s, r</span>
<span class="s">      dimension u(neq, s(neq), r(neq)</span>
<span class="s">      ...</span>
<span class="s">      return</span>
<span class="s">      end</span>

<span class="s">&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_lsodi</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Callable object to define the full Jacobian</span>
<span class="s">matrix dr/du where r = g - A*s. The</span>
<span class="s">signature of this function is ``jac(u,t,s)``,</span>
<span class="s">returning a matrix like the other ``jac``</span>
<span class="s">functions.</span>
<span class="s">&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,s&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,s&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;jac_lsodi_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_lsodi_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Fortran subroutine for jac_lsodi.</span>
<span class="s">This subroutine has the signature::</span>

<span class="s">       subroutine jac_lsodi_f77</span>
<span class="s">      1  (neq, t, u, s, ml, mu, pd, nrowpd)</span>
<span class="s"> Cf2py intent(in, hide) neq, ml, mu, nrowpd</span>
<span class="s"> Cf2py intent(out) pd</span>
<span class="s">       integer neq, ml, mu, nrowpd</span>
<span class="s">       double precision t, u, pd, s</span>
<span class="s">       dimension u(neq), s(neq), pd(nrowpd, neq)</span>
<span class="s">       pd = ...</span>
<span class="s">       return</span>
<span class="s">       end</span>

<span class="s">&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_banded_lsodi</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Callable object to define the banded Jacobian</span>
<span class="s">matrix dr/du where r = g - A*s. The</span>
<span class="s">signature is ``jac(u,t,s,ml,mu)``,</span>
<span class="s">where ``ml`` and ``mu`` are the lower and</span>
<span class="s">upper half-bandwidth of the banded matrix.</span>
<span class="s">&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,s,ml,mu&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,s,ml,mu&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;jac_banded_lsodi_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_banded_lsodi_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Fortran subroutine for jac_banded_lsodi.</span>
<span class="s">This subroutine has the signature::</span>

<span class="s">       subroutine jac_banded_lsodi_f77</span>
<span class="s">      1  (neq, t, u, s, ml, mu, pd, nrowpd)</span>
<span class="s"> Cf2py intent(in, hide) neq, ml, mu, nrowpd</span>
<span class="s"> Cf2py intent(out) pd</span>
<span class="s">       integer neq, ml, mu, nrowpd</span>
<span class="s">       double precision t, u, pd, s</span>
<span class="s">       dimension u(neq), s(neq), pd(nrowpd, neq)</span>
<span class="s">       pd = ...</span>
<span class="s">       return</span>
<span class="s">       end</span>

<span class="s">&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">adda_lsodi</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Callable object to add the matrix A = A(u,t)</span>
<span class="s">to another matrix p stored in the same form as A.</span>
<span class="s">The signature is ``adda(u,t,p)`` and it returns</span>
<span class="s">a matrix p+A (square matrix as the Jacobian).</span>
<span class="s">&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,p&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,p&#39;</span><span class="p">,</span>
        <span class="n">array_order</span><span class="o">=</span><span class="s">&#39;Fortran&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;adda_lsodi_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">adda_lsodi_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Fortran subroutine for adda_lsodi.</span>
<span class="s">This subroutine has the signature::</span>

<span class="s">        subroutine adda_lsodi_f77</span>
<span class="s">       1  (neq, t, u, ml, mu, pd, nrowpd)</span>
<span class="s">  Cf2py intent(in, hide) neq, ml, mu</span>
<span class="s">  Cf2py intent(in, hide), depend(pd) nrowpd</span>
<span class="s">  Cf2py intent(in, out) pd</span>
<span class="s">        integer neq, ml, mu, nrowpd</span>
<span class="s">        double precision t, u, pd</span>
<span class="s">        dimension u(neq), pd(nrowpd, neq)</span>
<span class="s">        pd = ...</span>
<span class="s">        return</span>
<span class="s">        end</span>

<span class="s">&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">adda_banded_lsodi</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Callable object to add the banded matrix</span>
<span class="s">A = A(u,t) to another matrix stored P in the</span>
<span class="s">same form as A. For a banded matrix, A(i,j) is</span>
<span class="s">added to P(i-j+mu+1,j). The signature is</span>
<span class="s">``adda(u,t,p,ml,mu)`` and it returns a banded</span>
<span class="s">matrix.</span>
<span class="s">&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,p,ml,mu&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,p,ml,mu&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;adda_banded_lsodi_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">adda_banded_lsodi_f77</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Fortran subroutine for adda_banded.</span>
<span class="s">This subroutine has the signature::</span>

<span class="s">       subroutine adda_banded_lsodi_f77(neq, t,</span>
<span class="s">      1                  u, ml, mu, pd, nrowpd)</span>
<span class="s"> Cf2py intent(in, hide) neq, ml, mu</span>
<span class="s"> Cf2py intent(in, hide), depend(pd) nrowpd</span>
<span class="s"> Cf2py intent(in, out) pd</span>
<span class="s">       integer neq, ml, mu, nrowpd</span>
<span class="s">       double precision t, u, pd</span>
<span class="s">       dimension u(neq), pd(nrowpd, neq)</span>
<span class="s">       pd = ...</span>
<span class="s">       return</span>
<span class="s">       end</span>

<span class="s">&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">jac_lsodis</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Callable object to supply the j-th column of</span>
<span class="s">the sparse Jacobian matrix dr/du where</span>
<span class="s">r = g - A*s. The signature is ``jac(u,t,s,j,ia,ja)``</span>
<span class="s">and a vector is returned.</span>
<span class="s">&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,s,j-1,ia,ja&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,s,j,ia,ja&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;jac_lsodis_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">adda_lsodis</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Callable object to add j-th column of matrix</span>
<span class="s">A = A(u,t) to another matrix stored in sparse</span>
<span class="s">form. The signature is ``adda(u,t,j,ia,ja,p)``</span>
<span class="s">and it returns a vector.</span>
<span class="s">&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,j-1,ia,ja,p&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,j,ia,ja,p&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;adda_lsodis_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>
    <span class="n">jac_lsoibt</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Callable object to supply the jth column of</span>
<span class="s">the Jacobian matrix dr/du where r = g - A*s,</span>
<span class="s">stored in block-tridiagonal form.</span>
<span class="s">The signature is jac(u,t,s), and the return value</span>
<span class="s">is a tuple (pa,pb,pc), where each of these</span>
<span class="s">arrays has size mb*mb*nb, mb and nb being two</span>
<span class="s">parameters that can be set (see the help line for</span>
<span class="s">the parameters in the doc string of Lsoibt).</span>
<span class="s">pa, pb, and pc are to be loaded with partial</span>
<span class="s">derivatives (elements of the Jacobian matrix)</span>
<span class="s">on output, in terms of the block-tridiagonal</span>
<span class="s">structure assumed. That is, load the diagonal</span>
<span class="s">blocks into pa, the superdiagonal blocks (and</span>
<span class="s">block (nb,nb-2)) into pb, and the subdiagonal</span>
<span class="s">blocks (and block (1,3)) into pc.</span>
<span class="s">The blocks in block-row k of dr/du are to be</span>
<span class="s">loaded into pa(*,*,k), pb(*,*,k), and</span>
<span class="s">pc(*,*,k).</span>
<span class="s">Thus the affect of this function should be::</span>

<span class="s">  pa(i,j,k) = ( (i.j) element of k-th diagonal</span>
<span class="s">              block of dr/du)</span>
<span class="s">  pb(i,j,k) = ( (i,j) element of block (k,k+1)</span>
<span class="s">              of dr/du, or block (nb,nb-2) if</span>
<span class="s">              k == nb)               </span><span class="se">\</span>
<span class="s">  pc(i,j,k) = ( (i,j) element of block (k,k-1)</span>
<span class="s">              of dr/du, or block (1,3) if k==1).&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,s&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,s&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;jac_lsoibt_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">adda_lsoibt</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Callable object to add matrix A = A(u,t) to</span>
<span class="s">another matrix P, stored in block-tridiagonal</span>
<span class="s">form. The signature is  adda(u,t,pa,pb,pc), which</span>
<span class="s">should return (pa,pb,pc) as described for the</span>
<span class="s">jac_lsoibt parameter.</span>
<span class="s">&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="n">paralist_old</span><span class="o">=</span><span class="s">&#39;u,t,pa,pb,pc&#39;</span><span class="p">,</span>
        <span class="n">paralist_new</span><span class="o">=</span><span class="s">&#39;t,u,pa,pb,pc&#39;</span><span class="p">,</span>
        <span class="n">name_wrapped</span><span class="o">=</span><span class="s">&#39;adda_lsoibt_f77&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">callable</span><span class="p">),</span>

    <span class="n">seth</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Element threshhold for sparsity determination.&#39;</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>

    <span class="n">corrector_iter_method</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Corrector iteration method choice.&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>

    <span class="n">lrw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Length of real work array.&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>

    <span class="n">liw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Length of integer work array, similiar as &lt;lrw&gt;.&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>

    <span class="n">moss</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39; Method to obtain sparse structure of Jacobian.&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>

    <span class="n">max_hnil</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Maximum no of warning messages to be printed.&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>

    <span class="n">max_ordn</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Maximum order in nonstiff methods.&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>

    <span class="n">max_ords</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Maximum order in stiff methods.&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>

    <span class="c"># ja, ia, ja, ic are used to describe sparse structure of</span>
    <span class="c"># matrices in Lsodes and Lsodis.</span>
    <span class="n">ja</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Integer array containing the row indices where</span>
<span class="s">the nonzero elements occur, in columnwise</span>
<span class="s">order. Describes the sparsity matrix structure</span>
<span class="s">together with ia.</span>
<span class="s">In Lsodes, ia and ja describe the structure of</span>
<span class="s">Jacobian matrix; while in Lsodis, ia and ja are</span>
<span class="s">used to describe the structure of matrix A.&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span>
        <span class="c"># integer sequence</span>
        <span class="n">extra_check</span><span class="o">=</span><span class="k">lambda</span> <span class="n">int_seq</span><span class="p">:</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span><span class="n">int_seq</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()),</span>

    <span class="n">ia</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Integer array with length neq+1 which contains</span>
<span class="s">starting locations in ja of the descriptions</span>
<span class="s">for columns 1...neq. ia(1) == 1. The last element</span>
<span class="s">ia[neq+1] should equal to the total number of</span>
<span class="s">nonzero locations assumed.</span>
<span class="s">For each column j = 1...neq, the values of the</span>
<span class="s">row index i in column j, where a nonzero element</span>
<span class="s">may occur, are given by i == ja(k) where ia(j) &lt;=&#39;</span>
<span class="s">k &lt; ia(j+1).&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span>
        <span class="c"># integer sequence</span>
        <span class="n">extra_check</span><span class="o">=</span><span class="k">lambda</span> <span class="n">int_seq</span><span class="p">:</span> \
             <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span><span class="n">int_seq</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()),</span>

    <span class="n">jc</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Integer array which describes the sparsity</span>
<span class="s">Jacobian structure together with ic, like ia</span>
<span class="s">and ja. In Lsodis, ia and ja describe the sparse</span>
<span class="s">structure of matrix A, while ic and jc describe</span>
<span class="s">the sparse structure of Jacobian matrix.&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span>
        <span class="c"># integer sequence</span>
        <span class="n">extra_check</span><span class="o">=</span><span class="k">lambda</span> <span class="n">int_seq</span><span class="p">:</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span><span class="n">int_seq</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()),</span>

    <span class="n">ic</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Array which contains starting locations in jc.&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span>
        <span class="c"># integer sequence</span>
        <span class="n">extra_check</span><span class="o">=</span><span class="k">lambda</span> <span class="n">int_seq</span><span class="p">:</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span><span class="n">int_seq</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()),</span>

    <span class="c"># mb, nb describe the block-tridiagonal form of matrix.</span>
    <span class="n">mb</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;Block size. Describe the block-tridiagonal form &#39;</span>\
              <span class="s">&#39;of matrix A together with nb.&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="n">extra_check</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">&gt;=</span><span class="mi">1</span><span class="p">),</span>

    <span class="n">nb</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">help</span><span class="o">=</span><span class="s">&#39;&#39;&#39;Number of blocks in the main diagonal.</span>
<span class="s">In each of the nb block-rows of the matrix P</span>
<span class="s">(each consisting of mb consecutive rows), the</span>
<span class="s">nonzero elements are to lie in three</span>
<span class="s">consecutive mb by mb blocks.  In block-rows 2</span>
<span class="s">through nb-1, these are centered about the</span>
<span class="s">main diagonal. In block rows 1 and nb, they</span>
<span class="s">are the diagonal blocks and the two blocks</span>
<span class="s">adjacent to the diagonal block.  (Thus block</span>
<span class="s">positions (1,3) and (nb,nb-2) can be nonzero.)</span>
<span class="s">Require: mb&gt;=1, nb&gt;=4, mb*nb==neq.&#39;&#39;&#39;</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
        <span class="n">extra_check</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="o">&gt;=</span><span class="mi">4</span><span class="p">),</span>

    <span class="p">)</span>

<span class="kn">import</span> <span class="nn">solvers</span>
<span class="n">solvers</span><span class="o">.</span><span class="n">_parameters</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_parameters_Odepack</span><span class="p">)</span>


<div class="viewcode-block" id="Odepack"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack">[docs]</a><span class="k">class</span> <span class="nc">Odepack</span><span class="p">(</span><span class="n">Solver</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a superclass for wrapping for seven solvers in the Fortran</span>
<span class="sd">    package ODEPACK (available at the netlib repository:</span>
<span class="sd">    www.netlib.org/odepack).</span>

<span class="sd">    *Solvers for explicitly given systems.*</span>
<span class="sd">    For each of the following solvers, it is assumed that the ODEs are</span>
<span class="sd">    given explicitly, so that the system can be written in the form</span>
<span class="sd">    du/dt = f(u,t), where u is a vector of dependent variables, and t</span>
<span class="sd">    is a scalar.</span>

<span class="sd">    ===============  ==========================================================</span>
<span class="sd">    Name             Description</span>
<span class="sd">    ===============  ==========================================================</span>
<span class="sd">       Lsode         A wrapper of dlsode, the basic solver in ODEPACK for</span>
<span class="sd">                     stiff and nonstiff systems of the form u&#39; = f.</span>

<span class="sd">                     In the stiff case, it treats the Jacobian matrix df/du as</span>
<span class="sd">                     either a dense (full) or a banded matrix, and as either</span>
<span class="sd">                     user-supplied or internally approximated by differences.</span>

<span class="sd">                     It uses Adams methods (predictor-corrector) in the</span>
<span class="sd">                     nonstiff case, and Backward Differentiation Formula (BDF)</span>
<span class="sd">                     methods (the Gear methods) in the stiff case.  The linear</span>
<span class="sd">                     systems that arise are solved by direct methods (LU</span>
<span class="sd">                     factorization/backsolve).</span>

<span class="sd">       Lsodes        Solves systems u&#39; = f, and in the stiff case</span>
<span class="sd">                     treats Jacobian matrix in general sparse form. It can</span>
<span class="sd">                     determine the sparsity structure on its own, or optionally</span>
<span class="sd">                     accepts this information from the user.</span>
<span class="sd">                     It then uses parts of the Yale Sparse Matrix Package (YSMP)</span>
<span class="sd">                     to solve the linear systems that arise, by a sparse</span>
<span class="sd">                     (direct) LU factorization/backsolve method.</span>

<span class="sd">       Lsoda         Solves systems u&#39; = f, with a dense or banded</span>
<span class="sd">                     Jacobian when the problem is stiff, but it automatically</span>
<span class="sd">                     selects between nonstiff (Adams) and stiff (BDF)</span>
<span class="sd">                     methods. It uses the nonstiff method initially, and</span>
<span class="sd">                     dynamically monitors data in order to decide which</span>
<span class="sd">                     method to use.</span>

<span class="sd">       Lsodar        A variant of Lsoda allowing for constraints.</span>
<span class="sd">                     It solves u&#39; = with dense or banded</span>
<span class="sd">                     Jacobian and automatic method selection, and at the same</span>
<span class="sd">                     time, it solves g(u,t) = 0. This is often useful for</span>
<span class="sd">                     finding stopping conditions, or for finding points</span>
<span class="sd">                     at which a switch is to be made in the function f.</span>
<span class="sd">    ===============  ==========================================================</span>

<span class="sd">     *Solvers for linearly implicit systems.*</span>
<span class="sd">     The following solvers treat systems in the linearly implicit form::</span>

<span class="sd">            A(u,t) du/dt = g(u,t),</span>

<span class="sd">     where A is a square matrix, i.e., with the derivative</span>
<span class="sd">     du/dt implicit, but linearly so.</span>
<span class="sd">     These solvers allow A to be singular, in which case the system is a</span>
<span class="sd">     differential-algebraic equation (DAE) system.</span>
<span class="sd">     In that case, the user must be very careful to supply a well-posed</span>
<span class="sd">     problem with consistent initial conditions.</span>

<span class="sd">    ===============  ==========================================================</span>
<span class="sd">    Name             Description</span>
<span class="sd">    ===============  ==========================================================</span>
<span class="sd">       Lsodi         Solves linearly implicit systems in which the</span>
<span class="sd">                     matrices involved (A, dg/du, and d(A u&#39;)/du) are all</span>
<span class="sd">                     assumed to be either dense or banded.</span>

<span class="sd">       Lsodibt       Solves linearly implicit systems in which the matrices</span>
<span class="sd">                     involved are all assumed to be block-tridiagonal.  Linear</span>
<span class="sd">                     systems are solved by the LU method.</span>

<span class="sd">       Lsodis        Solves linearly implicit systems in which the</span>
<span class="sd">                     matrices involved are all assumed to be sparse.</span>
<span class="sd">                     Either determines the sparsity structure or accepts it from</span>
<span class="sd">                     the user, and uses parts of the Yale Sparse Matrix Package</span>
<span class="sd">                     to solve the linear systems that arise, by a direct method.</span>
<span class="sd">    ===============  ==========================================================</span>

<span class="sd">    *Note*: For large ODE systems the user is encouraged that users provide</span>
<span class="sd">    an f2py-compiled Fortran subroutine or a multi-line string Fortran code</span>
<span class="sd">    to define the ODE. This would help to improve efficiency.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Default parameter-list for all solvers in OdePack</span>
    <span class="c"># Note: f and jac are not valid in some specific solvers.</span>

    <span class="n">_optional_parameters</span> <span class="o">=</span> <span class="n">Solver</span><span class="o">.</span><span class="n">_optional_parameters</span> <span class="o">+</span> \
        <span class="p">[</span><span class="s">&#39;atol&#39;</span><span class="p">,</span> <span class="s">&#39;rtol&#39;</span><span class="p">,</span> <span class="s">&#39;adams_or_bdf&#39;</span><span class="p">,</span> <span class="s">&#39;order&#39;</span><span class="p">,</span>
         <span class="s">&#39;nsteps&#39;</span><span class="p">,</span> <span class="s">&#39;first_step&#39;</span><span class="p">,</span> <span class="s">&#39;min_step&#39;</span><span class="p">,</span>
         <span class="s">&#39;max_step&#39;</span><span class="p">,</span> <span class="s">&#39;corrector_iter_method&#39;</span><span class="p">,</span> <span class="s">&#39;lrw&#39;</span><span class="p">,</span> <span class="s">&#39;liw&#39;</span><span class="p">]</span>

    <span class="c"># Error messages to print out,</span>
    <span class="c"># corresponding to different values of return status-flag.</span>
    <span class="n">_error_messages</span> <span class="o">=</span> <span class="p">{</span>\
    <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    An excessive amount of work (more than &quot;max_step&quot; steps) was done on this</span>
<span class="s">    call, before completing the requested task, but the integration was</span>
<span class="s">    otherwise successful as far as &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    Too much accuracy was requested for the precision of the machine being</span>
<span class="s">    used.  To continue, the tolerance parameters must be reset. This was</span>
<span class="s">    detected before completing the requested task, but the integration was</span>
<span class="s">    successful as far as &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">3</span><span class="p">:</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    Illegal input was detected, before taking any integration steps.</span>
<span class="s">    Current T is &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">4</span><span class="p">:</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    There were repeated error-test failures on one attempted step, before</span>
<span class="s">    completing the requested task. The problem may have a singularity, or the</span>
<span class="s">    input may be inappropriate, but integration was successful as far as &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">5</span><span class="p">:</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    There were repeated convergence-test failures on one attempted step, before</span>
<span class="s">    completing the requested task. This may be caused by an inaccurate Jacobian</span>
<span class="s">    matrix, if one is being used. But integration was successful as far as&#39;&#39;&#39;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">6</span><span class="p">:</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    EWT(i) became zero for some i during the integration. Pure relative error</span>
<span class="s">    control (ATOL(i)=0.0) was requested on a variable which has now vanished.</span>
<span class="s">    The integration was successful as far as &#39;&#39;&#39;</span><span class="p">,</span>
    <span class="o">-</span><span class="mi">7</span><span class="p">:</span><span class="s">&#39;&#39;</span><span class="p">}</span>

    <span class="n">_extra_args_fortran</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c"># Dictionary for extra parameters in all external functions in Fortran</span>
    <span class="c"># package ODEPACK.</span>
    <span class="c"># For example, _extra_args_fortran[&#39;jac_extra_args&#39;] is defined as</span>
    <span class="c"># (&#39;self.ml&#39;,&#39;self.mu&#39;) when jac is a banded Jacobian matrix.</span>

    <span class="n">_iwork_index</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">:</span><span class="s">&#39;order&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="s">&#39;nsteps&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span><span class="s">&#39;max_hnil&#39;</span><span class="p">}</span>
    <span class="c"># Index in iwork_in to supply optional inputs.</span>
    <span class="n">_rwork_index</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">:</span><span class="s">&#39;first_step&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="s">&#39;max_step&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span><span class="s">&#39;min_step&#39;</span><span class="p">}</span>
    <span class="c"># Index in rwork_in to supply optional inputs.</span>

<div class="viewcode-block" id="Odepack.adjust_parameters"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.adjust_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Special settings for properties of input parameters.&quot;&quot;&quot;</span>
        <span class="c"># If f is input in form of f(u,t), wrap f to f_f77 for Fortran code.</span>
        <span class="k">if</span> <span class="s">&#39;f&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;f&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;f_f77&#39;</span>
        <span class="c"># If f is input in form of f(t,u),</span>
        <span class="c"># wrap f_f77 to the general form f(u,t) for switch_to()</span>
        <span class="k">if</span> <span class="s">&#39;f_f77&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;f_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;f_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;f_f77&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;f&#39;</span>

        <span class="c"># These default values are unnecessary in ODEPACK.</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;order&#39;</span><span class="p">,</span> <span class="s">&#39;jac&#39;</span><span class="p">,</span> <span class="s">&#39;nsteps&#39;</span><span class="p">,</span> <span class="s">&#39;seth&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">:</span>
                <span class="k">if</span> <span class="s">&#39;default&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s">&#39;default&#39;</span><span class="p">]</span>

        <span class="c"># If jac is input in form of jac(u,t),</span>
        <span class="c"># wrap jac to jac_f77 for Fortran code.</span>
        <span class="k">if</span> <span class="s">&#39;jac&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac&#39;</span><span class="p">][</span><span class="s">&#39;array_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Fortran&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac_f77&#39;</span>
        <span class="c"># If jac is input in form of jac(t,u),</span>
        <span class="c"># wrap jac_f77 to the general form jac(u,t) for switch_to().</span>
        <span class="k">if</span> <span class="s">&#39;jac_f77&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_f77&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac&#39;</span>
        <span class="n">Solver</span><span class="o">.</span><span class="n">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Odepack.initialize"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Import extension module _odesolver and check that it exists.&#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">_odepack</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_odepack</span> <span class="o">=</span> <span class="n">_odepack</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s">&#39;Cannot find the extension module _odepack.</span><span class="se">\n</span><span class="s">Run setup.py again and investigate why _odepack.so was not successfully built.&#39;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Odepack.func_wrapper"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.func_wrapper">[docs]</a>    <span class="k">def</span> <span class="nf">func_wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This function is defined to wrap user-defined functions with new</span>
<span class="sd">        forms of parameter-list, or wrap the returned values as numpy arrays.</span>

<span class="sd">        Firstly, in odespy, all the user-supplied functions should have a</span>
<span class="sd">        parameter list starts with &quot;u,t,...&quot;. But in some special subclasses,</span>
<span class="sd">        (like solvers in ODEPACK), all the parameter lists of user-defined</span>
<span class="sd">        functions start with &quot;t,u,...&quot;. So we need this general function to</span>
<span class="sd">        wrap all these user-defined functions.</span>

<span class="sd">        Secondly, in some user-defined functions, according to the different</span>
<span class="sd">        start indices in Fortran and Python, we need to make special wrapping</span>
<span class="sd">        for these uncompability. For an example, in user-defined function</span>
<span class="sd">        &quot;jac_column&quot;, column index is an internally valued parameter in</span>
<span class="sd">        Fortran code. In Python, it starts from 0 instead of 1 in Fortran.</span>
<span class="sd">        So we need to wrap the parameter list of user-defined &quot;jac_column&quot; from</span>
<span class="sd">        &quot;u,t,j&quot; to &quot;t,u,j+1&quot;. That is, define the Jacobian function as</span>
<span class="sd">        lambda t,u,j: jac_column(u,t,j-1).</span>

<span class="sd">        Furthermore, the return value of user-defined functions need to be</span>
<span class="sd">        wrapped to Numpy arrays with great numerical features, e.g.</span>
<span class="sd">        vectorization and array slicing. In order to avoid unnecessary array</span>
<span class="sd">        copy by F2PY, it is always recommended to explicitly transform all</span>
<span class="sd">        Numpy arrays to Fortran order in Python code.</span>

<span class="sd">        This functions is not intended for simple solvers. So it is not called</span>
<span class="sd">        automatically in current version. But for some complicated solvers as</span>
<span class="sd">        ones in ODEPACK, it is very useful and convenient.</span>

<span class="sd">        Future developers can call this functions with appropriate locations</span>
<span class="sd">        and corresponding property-setting in adjust_parameters().</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span>
        <span class="c"># Extract function parameters that are required to be wrapped</span>
        <span class="n">func_list</span> <span class="o">=</span> <span class="p">[[</span><span class="n">name</span><span class="p">,</span>
                      <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;array_order&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
                      <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;paralist_old&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
                      <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;paralist_new&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
                      <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)]</span>
                     <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">parameters</span> \
                         <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span> <span class="ow">and</span> \
                         <span class="s">&#39;type&#39;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="ow">and</span> \
                         <span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="nb">callable</span> <span class="ow">or</span> \
                          <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s">&#39;type&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="p">(</span><span class="nb">callable</span><span class="p">,</span> <span class="nb">str</span><span class="p">))</span> <span class="ow">and</span> \
                         <span class="p">(</span><span class="s">&#39;paralist_new&#39;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="ow">or</span> \
                          <span class="s">&#39;array_order&#39;</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">])]</span>
        <span class="c"># name in self.__dict__  --&gt; existing attributes in current instance</span>
        <span class="c"># parameters[name][&#39;type&#39;] is callable or (callable, str)</span>
        <span class="c">#             --&gt;     callable objects</span>
        <span class="c"># &#39;paralist_new&#39; in parameters[name]</span>
        <span class="c">#    --&gt; new parameter-list is defined to be wrapped</span>
        <span class="c"># &#39;array_order&#39; in parameters[name]</span>
        <span class="c">#    --&gt; this function return an array, and should be wrapped either in</span>
        <span class="c">#    Fortran order or C (default) order.</span>
        <span class="n">func_input</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">arg_old</span><span class="p">,</span> <span class="n">arg_new</span><span class="p">,</span> <span class="n">name_new</span> <span class="ow">in</span> <span class="n">func_list</span><span class="p">:</span>
            <span class="c"># e.g. name     = &#39;jac&#39;</span>
            <span class="c">#      arg_old  = &#39;u,t&#39;</span>
            <span class="c">#      arg_new  = &#39;t,u&#39;</span>
            <span class="c">#      order    = &#39;Fortran&#39;</span>
            <span class="c">#      name_new = &#39;jac_f77&#39;</span>
            <span class="c">#  Then:</span>
            <span class="c">#  self.jac_f77 = lambda t,u: np.asarray(jac(u,t), order=&#39;Fortran&#39;)</span>
            <span class="n">func_input</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">wrap_string</span> <span class="o">=</span> <span class="s">&#39;lambda </span><span class="si">%s</span><span class="s">: &#39;</span> <span class="o">%</span> \
                <span class="p">(</span><span class="n">arg_new</span> <span class="k">if</span> <span class="n">arg_new</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">arg_old</span><span class="p">)</span>
            <span class="n">wrap_string</span> <span class="o">+=</span> <span class="s">&#39;np.asarray(&#39;</span> <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="s">&#39;&#39;</span>
            <span class="n">wrap_string</span> <span class="o">+=</span> <span class="s">&#39;func_input[&quot;</span><span class="si">%s</span><span class="s">&quot;](</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">arg_old</span><span class="p">)</span>
            <span class="n">wrap_string</span> <span class="o">+=</span> <span class="s">&#39;, order=&quot;Fortran&quot;&#39;</span> <span class="k">if</span> <span class="n">order</span><span class="o">==</span><span class="s">&#39;Fortran&#39;</span> <span class="k">else</span> <span class="s">&#39;&#39;</span>
            <span class="n">wrap_string</span> <span class="o">+=</span> <span class="s">&#39;)&#39;</span> <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="s">&#39;&#39;</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name_new</span><span class="p">,</span> <span class="nb">eval</span><span class="p">(</span><span class="n">wrap_string</span><span class="p">,</span> <span class="nb">locals</span><span class="p">()))</span>
</div>
<div class="viewcode-block" id="Odepack.check_liwlrw"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.check_liwlrw">[docs]</a>    <span class="k">def</span> <span class="nf">check_liwlrw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        If the lengths of work arrays are specified by users, check whether</span>
<span class="sd">        they are greater than the required lengths of Fortran solvers. &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;liw&#39;</span><span class="p">,</span> <span class="s">&#39;lrw&#39;</span><span class="p">):</span>
            <span class="n">min_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">+</span><span class="s">&#39;_min&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">min_value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">min_value</span><span class="p">:</span>
                    <span class="k">print</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">          Insufficient input! &quot;</span><span class="si">%s</span><span class="s">&quot;=</span><span class="si">%d</span><span class="s"> are reset to be the minimum size = </span><span class="si">%d</span><span class="s"> &#39;&#39;&#39;</span>\
                        <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">min_value</span><span class="p">)</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">min_value</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Odepack.check_tol"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.check_tol">[docs]</a>    <span class="k">def</span> <span class="nf">check_tol</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        atol &amp; rtol should be defined as scalars or vectors with length neq.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;atol&#39;</span><span class="p">,</span> <span class="s">&#39;rtol&#39;</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                    <span class="s">&#39;</span><span class="si">%s</span><span class="s"> has an illegal length = </span><span class="si">%d</span><span class="s">! Valid length is </span><span class="si">%d</span><span class="s"> or 1.&#39;</span> \
                        <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Odepack.check_pars"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.check_pars">[docs]</a>    <span class="k">def</span> <span class="nf">check_pars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Some pairs of parameters should be input simutaneously.&#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">pars</span> <span class="ow">in</span> <span class="p">((</span><span class="s">&#39;ia&#39;</span><span class="p">,</span> <span class="s">&#39;ja&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;ic&#39;</span><span class="p">,</span> <span class="s">&#39;jc&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;mb&#39;</span><span class="p">,</span> <span class="s">&#39;nb&#39;</span><span class="p">)):</span>
            <span class="n">arg_a</span><span class="p">,</span> <span class="n">arg_b</span> <span class="o">=</span> <span class="n">pars</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_a</span><span class="p">)</span> <span class="o">+</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_b</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span><span class="s">&#39;</span><span class="se">\</span>
<span class="s">        Error! </span><span class="si">%s</span><span class="s"> and </span><span class="si">%s</span><span class="s"> have to be input simutaneously!&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">arg_a</span><span class="p">,</span> <span class="n">arg_b</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Odepack.check_iaja"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.check_iaja">[docs]</a>    <span class="k">def</span> <span class="nf">check_iaja</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        ``ia``, ``ja``, ``ic``, ``jc`` are optional inputs to describe</span>
<span class="sd">        arbitrary sparse structure of matrix.</span>

<span class="sd">        ``ia`` and ``ja`` are used in dlsodes, dlsodis.</span>
<span class="sd">        ``ic`` and ``jc`` are used only in dlsodis.</span>

<span class="sd">        There are special requirements for their values::</span>

<span class="sd">            len(ia/ic) = neq + 1</span>
<span class="sd">            (ia/ic)[0] = 1</span>
<span class="sd">            (ia/ic)[-1] = 1 + len(ja/jc)</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">pars</span> <span class="ow">in</span> <span class="p">((</span><span class="s">&#39;ia&#39;</span><span class="p">,</span><span class="s">&#39;ja&#39;</span><span class="p">),(</span><span class="s">&#39;ic&#39;</span><span class="p">,</span><span class="s">&#39;jc&#39;</span><span class="p">)):</span>
            <span class="n">arg_a</span><span class="p">,</span> <span class="n">arg_b</span> <span class="o">=</span> <span class="n">pars</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_a</span><span class="p">):</span>
                <span class="n">array_a</span><span class="p">,</span><span class="n">array_b</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_a</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg_b</span><span class="p">)</span>
                <span class="n">err_messages</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">        Illegal input! </span><span class="si">%s</span><span class="s">(=</span><span class="si">%s</span><span class="s">) should have a length </span><span class="si">%d</span><span class="s"> (= neq+1)!</span><span class="se">\n\n</span><span class="s">&#39;&#39;&#39;</span>\
                   <span class="o">%</span> <span class="p">(</span><span class="n">arg_a</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">array_a</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
                                <span class="sd">&#39;&#39;&#39;\</span>
<span class="sd">        Illegal input! %s[0](=%d) should be equal to 1!\n\n&#39;&#39;&#39;</span>\
                   <span class="o">%</span> <span class="p">(</span><span class="n">arg_a</span><span class="p">,</span> <span class="n">array_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                <span class="sd">&#39;&#39;&#39;\</span>
<span class="sd">        Illegal input! %s[neq+1](=%d) should be equal to 1</span>
<span class="sd">        plus the length of %s(=%d), which represents the total</span>
<span class="sd">        number of nonzero locations assumed in the matrix.\n&#39;&#39;&#39;</span> \
                   <span class="o">%</span> <span class="p">(</span><span class="n">arg_a</span><span class="p">,</span> <span class="n">array_a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">arg_b</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">array_b</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">iaja_check</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">array_a</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                              <span class="n">array_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">,</span>
                              <span class="n">array_a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array_b</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">error_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">iaja_check</span><span class="p">[</span><span class="n">error_index</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="n">err_messages</span><span class="p">[</span><span class="n">error_index</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Odepack.validate_data"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.validate_data">[docs]</a>    <span class="k">def</span> <span class="nf">validate_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Common validity check in Odepack.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c"># lower- &amp; upper-bound for banded Jacobian in range [0,neq]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">Solver</span><span class="o">.</span><span class="n">validate_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_tol</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_pars</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_iaja</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_liwlrw</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="Odepack.set_iwork_rwork"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.set_iwork_rwork">[docs]</a>    <span class="k">def</span> <span class="nf">set_iwork_rwork</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialize arrays for optional inputs, and calculate the</span>
<span class="sd">        required length of work arrays in Fortran code.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c"># calculate the required length of work arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_liw_min</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_lrw_min</span><span class="p">()</span>

        <span class="c"># Indices of optional inputs in work arrays</span>
        <span class="n">iwork_index</span><span class="p">,</span> <span class="n">rwork_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iwork_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rwork_index</span>

        <span class="c"># Initialize work arrays.</span>
        <span class="n">length_iwork_in</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">iwork_index</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">length_rwork_in</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rwork_index</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">length_iwork_in</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rwork_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">length_rwork_in</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="c"># Put optional inputs into work arrays with specified indices.</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">iwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">rwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rwork_in</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="mf">0.</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Odepack.set_iopt"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.set_iopt">[docs]</a>    <span class="k">def</span> <span class="nf">set_iopt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialization for &quot;ipot&quot;, which is a flag to indicate whether optional</span>
<span class="sd">        parameters are specified in work arrays.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</div>
<div class="viewcode-block" id="Odepack.set_ydoti"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.set_ydoti">[docs]</a>    <span class="k">def</span> <span class="nf">set_ydoti</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        ``ydoti`` is an array used in linearly implicit solvers.</span>
<span class="sd">        It has to be extended if its length is smaller than neq.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ydoti</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;ydoti&#39;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="c"># flag to indicate whether ydoti is supplied</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ydoti_flag</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ydoti</span><span class="o">!=</span><span class="p">[])</span>
        <span class="c"># extend the length of &#39;ydoti&#39; to neq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ydoti</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ydoti</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">ydoti</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Odepack.set_liw_min"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.set_liw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_liw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the necessary length of integer work arrays when it is not</span>
<span class="sd">        specified explicitly by users.</span>
<span class="sd">        Different solvers have different formulas.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</div>
<div class="viewcode-block" id="Odepack.set_lrw_min"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.set_lrw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_lrw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the necessary length of real work arrays for Fortran code.</span>
<span class="sd">        Different solvers have different formulas.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</div>
<div class="viewcode-block" id="Odepack.set_extra_args"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.set_extra_args">[docs]</a>    <span class="k">def</span> <span class="nf">set_extra_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Setting for extra parameters of user-defined functions.&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Odepack.set_jac"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.set_jac">[docs]</a>    <span class="k">def</span> <span class="nf">set_jac</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Set values for Jacobian matrix. In several solvers like Lsode,</span>
<span class="sd">        Jacobian matrix could be supplied either in full form or in banded form.</span>

<span class="sd">        This function intends to tell from which kind of Jacobian matrix</span>
<span class="sd">        is specified.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">None</span>
</div>
<div class="viewcode-block" id="Odepack.set_dummy_functions"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.set_dummy_functions">[docs]</a>    <span class="k">def</span> <span class="nf">set_dummy_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Functions have to get dummy values before they are passed to extension</span>
<span class="sd">        module even if they are not involved in current solver.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;jac_f77&#39;</span><span class="p">,</span> <span class="s">&#39;f_f77&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span><span class="mf">0.</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_column_f77&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jac_column_f77</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="mf">0.</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;g_f77&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">g_f77</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(())</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;ng&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ng</span> <span class="o">=</span> <span class="mi">0</span>

</div>
<div class="viewcode-block" id="Odepack.set_iter_method"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.set_iter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_iter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Set proper values for method-choices when it is not specified</span>
<span class="sd">        explicitly.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</div>
<div class="viewcode-block" id="Odepack.initialize_for_solve"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.initialize_for_solve">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_for_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        In the long parameter-lists for solvers in ODEPACK, quite a few</span>
<span class="sd">        parameters can be set automatically with proper values depending</span>
<span class="sd">        on values of other parameters.</span>
<span class="sd">        In this function, all the parameters of this kind are initialized</span>
<span class="sd">        with proper values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_iter_method</span><span class="p">()</span>     <span class="c"># method choice</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_wrapper</span><span class="p">()</span>        <span class="c"># wrap function parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_jac</span><span class="p">()</span>             <span class="c"># tell from which kind of Jacobian matrix</span>
                                   <span class="c"># are supplied:  banded, full or None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_dummy_functions</span><span class="p">()</span> <span class="c"># pass dummy values to extension module</span>
                                   <span class="c"># for functions that are not involved</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_extra_args</span><span class="p">()</span>      <span class="c"># Extra parameters for external functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adams_or_bdf</span> <span class="o">==</span> <span class="s">&#39;bdf&#39;</span><span class="p">))</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> \
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;moss&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_iwork_rwork</span><span class="p">()</span>     <span class="c"># work arrays initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_iopt</span><span class="p">()</span>            <span class="c"># Flag for optional inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ydoti</span><span class="p">()</span>           <span class="c"># Extend length of array ydoti</span>
        <span class="c"># itol is a flag to indicate whether tolerance parameters are input</span>
        <span class="c"># as scalars or vectors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">itol</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rtol</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)))</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> \
            <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atol</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">Solver</span><span class="o">.</span><span class="n">initialize_for_solve</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>   <span class="c"># Common settings in super class</span>
</div>
<div class="viewcode-block" id="Odepack.new_stepnr"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.new_stepnr">[docs]</a>    <span class="k">def</span> <span class="nf">new_stepnr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        When Fortran code returns a status ``istate==-1``, it indicates that</span>
<span class="sd">        there are excessive amount of steps detected.</span>
<span class="sd">        Then we could try to increase ``nsteps`` to avoid this error.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">nsteps</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;nsteps&#39;</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nsteps</span> <span class="o">==</span> <span class="mi">2000</span><span class="p">:</span>    <span class="c"># The maximum step-amount has been reached</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">        Failed iteration although step number has been set to 2000.</span>
<span class="s">        Please check your input.&#39;&#39;&#39;</span>
        <span class="n">mx_new</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nsteps</span><span class="o">+</span><span class="mi">200</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>
        <span class="c"># maximum limitation is set to 2000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsteps</span> <span class="o">=</span> <span class="n">mx_new</span>  <span class="c"># valid for the following steps</span>
        <span class="k">print</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">        Excessive amount of work detected!</span>
<span class="s">        Input step amount &quot;nsteps&quot;=</span><span class="si">%d</span><span class="s"> is not enough for iteration!</span>
<span class="s">        nsteps has been reset to </span><span class="si">%d</span><span class="s"> to avoid this error!&#39;&#39;&#39;</span>\
        <span class="o">%</span> <span class="p">(</span><span class="n">nsteps</span><span class="p">,</span> <span class="n">mx_new</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mx_new</span>
</div>
<div class="viewcode-block" id="Odepack.tol_multiply"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.tol_multiply">[docs]</a>    <span class="k">def</span> <span class="nf">tol_multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolsf</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This function is used to adjust tolerance parameters for Fortran part.</span>
<span class="sd">        When extension module returns a status &quot;istate&quot; as -2 or -3, it often</span>
<span class="sd">        indicates that there are excessive amount of steps detected.</span>
<span class="sd">        Then we could try to adjust tolerance settings with suggested factor</span>
<span class="sd">        to avoid this error.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">print</span> <span class="s">&#39;Tolerance is scaled by suggested factor </span><span class="si">%.2g</span><span class="s">&#39;&#39;&#39;</span> <span class="o">%</span> <span class="n">tolsf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rtol</span> <span class="o">*=</span> <span class="n">tolsf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atol</span> <span class="o">*=</span> <span class="n">tolsf</span>
</div>
<div class="viewcode-block" id="Odepack.expand_rwork"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.expand_rwork">[docs]</a>    <span class="k">def</span> <span class="nf">expand_rwork</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_lrw</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Length of real work array is smaller than actually required length.</span>
<span class="sd">	Then we could expand work array to avoid this error.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">print</span> <span class="s">&#39;The length of real work array has been reset to </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">new_lrw</span>
        <span class="k">if</span> <span class="n">expand</span><span class="p">:</span>          <span class="c"># Expand real arrays for linearly implicit solvers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">new_lrw</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">lrw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrw</span> <span class="o">=</span> <span class="n">new_lrw</span>
</div>
<div class="viewcode-block" id="Odepack.expand_iwork"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.expand_iwork">[docs]</a>    <span class="k">def</span> <span class="nf">expand_iwork</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_liw</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Extension module return an actually required length for</span>
<span class="sd">        integer work array when it is too short.</span>
<span class="sd">	Then we could expand work array to required length to avoid this error.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">print</span> <span class="s">&#39;The length of integer work array has been reset to </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">new_liw</span>
        <span class="k">if</span> <span class="n">expand</span><span class="p">:</span>          <span class="c"># Expand integer arrays for linearly implicit solvers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mf">0.</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">new_liw</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">liw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">liw</span> <span class="o">=</span> <span class="n">new_liw</span>
</div>
<div class="viewcode-block" id="Odepack.adjust_atol"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.adjust_atol">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_atol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u_current</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Error tolerance ``tol(i)`` may become zero for some ``i``</span>
<span class="sd">        during integration, where::</span>

<span class="sd">          tol = rtol(i) * u(i) + atol(i)</span>

<span class="sd">        It indicates that pure absolute tolerance (``atol(i)=0.0``)</span>
<span class="sd">        was requested.  In order to avoid possible divide-by-zero</span>
<span class="sd">        error, we find the indices of zero items and adjust</span>
<span class="sd">        ``atol`` to ``1e-8``.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">u_current</span><span class="p">))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">rtol</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">atol</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atol</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="c"># atol is set as a scalar float</span>
            <span class="c"># Convert scalar &quot;atol&quot; to be an array</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">atol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atol</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">itol</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tol</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="mf">0.</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">atol</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
                    <span class="c"># Increase absolute error</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">atol</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1e-8</span>
</div>
<div class="viewcode-block" id="Odepack.print_roots"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.print_roots">[docs]</a>    <span class="k">def</span> <span class="nf">print_roots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jroot</span><span class="p">,</span> <span class="n">t_current</span><span class="p">,</span> <span class="n">u_current</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Roots found at current T for some constraint functions. &#39;&#39;&#39;</span>
        <span class="n">g</span><span class="p">,</span> <span class="n">ng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_f77</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ng</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">):</span>  <span class="c"># ng is required if g is in Fortran</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t_current</span><span class="p">,</span> <span class="n">u_current</span><span class="p">,</span> <span class="n">ng</span><span class="o">=</span><span class="n">ng</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">t_current</span><span class="p">,</span> <span class="n">u_current</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ng</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">jroot</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>   <span class="c"># found root for i-th constraint equation</span>
                <span class="k">print</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">        Root found at t = </span><span class="si">%g</span><span class="s"> for </span><span class="si">%d</span><span class="s">th constraint function in g&#39;&#39;&#39;</span> \
                    <span class="o">%</span> <span class="p">(</span><span class="n">t_current</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">value_ith</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">ng</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">value</span>
                <span class="k">print</span> <span class="s">&#39;Error in location of root is </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">value_ith</span>

</div>
<div class="viewcode-block" id="Odepack.solve"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_points</span><span class="p">,</span> <span class="n">terminate</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This function is involved for non-linearly implicit</span>
<span class="sd">        solvers in ODEPACK, i.e., Lsode, Lsoda, Lsodar, and Lsodes.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">itermin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">terminate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span>   <span class="c"># flag to indicate dummy function</span>
        <span class="c"># Logical value cannot be transferred with f2py.</span>
        <span class="k">if</span> <span class="n">terminate</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>    <span class="c"># Dummy function</span>
            <span class="n">terminate_int</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">step_no</span><span class="p">,</span><span class="n">nt</span><span class="p">,</span><span class="n">neq</span><span class="p">:</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">terminate_int</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">step_no</span><span class="p">,</span><span class="n">nt</span><span class="p">,</span><span class="n">neq</span><span class="p">:</span> \
                <span class="nb">int</span><span class="p">(</span><span class="n">terminate</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">step_no</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_for_solve</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_data</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Invalid data in &quot;</span><span class="si">%s</span><span class="s">&quot;:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> \
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">)))</span>

        <span class="c"># Convert class-name to name of subroutine,</span>
        <span class="c"># e.g. Lsode -&gt; dlsode or slsode</span>
        <span class="n">solver_name</span> <span class="o">=</span> <span class="s">&#39;d&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="n">step_no</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
        <span class="n">nstop</span><span class="p">,</span> <span class="n">istate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">False</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">order</span><span class="o">=</span><span class="s">&quot;Fortran&quot;</span><span class="p">)</span>
        <span class="n">tried</span> <span class="o">=</span> <span class="mi">0</span>        <span class="c"># Number of attempts</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">finished</span><span class="p">:</span>
            <span class="n">istate</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c"># Extract _cpointers if functions are compiled with F2PY.</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f_f77</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_f77</span><span class="p">)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g_f77</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">g_f77</span><span class="p">)</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jac_f77</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">jac_f77</span><span class="p">)</span>
            <span class="n">jac_column</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jac_column_f77</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">jac_column_f77</span><span class="p">)</span>
            <span class="c"># call extension module</span>
            <span class="n">nstop</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">istate</span><span class="p">,</span> <span class="n">rinfo</span><span class="p">,</span> <span class="n">iinfo</span> <span class="o">=</span> \
                <span class="nb">apply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_odepack</span><span class="o">.</span><span class="n">solve</span><span class="p">,</span>
                      <span class="p">(</span><span class="n">terminate_int</span><span class="p">,</span> <span class="n">itermin</span><span class="p">,</span> <span class="n">nstop</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">itol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atol</span><span class="p">,</span>
                       <span class="n">istate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rwork_in</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lrw</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">liw</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">jac_column</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">mf</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ng</span><span class="p">,</span> <span class="n">solver_name</span><span class="p">),</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">_extra_args_fortran</span><span class="p">)</span>
            <span class="n">tried</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">nstop</span> <span class="o">==</span> <span class="n">step_no</span><span class="p">:</span>    <span class="c"># successful</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">tried</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">istate</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>         <span class="c"># roots founded for constraint equations</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">print_roots</span><span class="p">(</span><span class="n">iinfo</span><span class="p">[</span><span class="mi">17</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">nstop</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">nstop</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">tried</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">istate</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">tried</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">istate</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;Iteration stops at step Nr.</span><span class="si">%d</span><span class="s">,&quot;</span> <span class="o">%</span> <span class="n">nstop</span>
                <span class="k">print</span> <span class="s">&quot; when function TERMINATE return with True.&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="n">istate</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>                   <span class="c"># Error occurs!</span>
                <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">_error_messages</span><span class="p">[</span><span class="n">istate</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">rinfo</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">istate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>    <span class="c"># Increase maximum step-number.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_stepnr</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">istate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>  <span class="c"># Multiply tolerance with suggested factor</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tol_multiply</span><span class="p">(</span><span class="n">rinfo</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">istate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">3</span><span class="p">:</span>
                    <span class="c"># Illegal input was detected,</span>
                    <span class="c"># before taking any integration steps.</span>
                    <span class="k">if</span> <span class="n">iinfo</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lrw</span><span class="p">:</span>   <span class="c"># Real work array is too short.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">expand_rwork</span><span class="p">(</span><span class="n">iinfo</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">iinfo</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">liw</span><span class="p">:</span> <span class="c"># Integer work array is too short.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">expand_iwork</span><span class="p">(</span><span class="n">iinfo</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">rinfo</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">:</span>       <span class="c"># suggested factor for tolerance</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tol_multiply</span><span class="p">(</span><span class="n">rinfo</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c"># Other cases with istate returned as -3</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Interrupt</span>
                <span class="k">elif</span> <span class="n">istate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">6</span><span class="p">:</span>
                    <span class="c"># divide-zero-error when error(i) became 0 for some i</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">adjust_atol</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">nstop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">istate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">7</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">solver_name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;dlsoda&quot;</span><span class="p">,</span><span class="s">&quot;dlsodar&quot;</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">iinfo</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lrw</span><span class="p">:</span>
                            <span class="c"># Real work array is too short.</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">expand_rwork</span><span class="p">(</span><span class="n">iinfo</span><span class="p">[</span><span class="mi">7</span><span class="p">])</span>
                        <span class="k">elif</span> <span class="n">iinfo</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">liw</span><span class="p">:</span>
                            <span class="c"># Integer work array is too short.</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">expand_iwork</span><span class="p">(</span><span class="n">iinfo</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">tried</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>     <span class="c"># prevent endless loop</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;aborted execution of 5 tries...&#39;</span><span class="p">)</span>
                <span class="n">nstart</span><span class="p">,</span> <span class="n">istate</span> <span class="o">=</span> <span class="n">nstop</span><span class="p">,</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:</span><span class="n">nstop</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[:</span><span class="n">nstop</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span>
</div>
<div class="viewcode-block" id="Odepack.advance"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Odepack.advance">[docs]</a>    <span class="k">def</span> <span class="nf">advance</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        This function intends to one step forward for linearly implicit solvers</span>
<span class="sd">        (Lsodi, Lsodis, Lsoibt) in ODEPACK.</span>

<span class="sd">        For these linearly implicit solvers, if extra wrappers are</span>
<span class="sd">        added in Fortran code, there are often memory errors. Besides,</span>
<span class="sd">        sometimes there are unavoidable errors caused by bugs in the</span>
<span class="sd">        Ubuntu/Linux libraries as libc.  To make these solvers more</span>
<span class="sd">        reliable on all platforms, this function is used to call</span>
<span class="sd">        solvers in ODEPACK (dlsodi, dlsodis, dlsoibt) directly without</span>
<span class="sd">        any wrappers in Fortran. However, this would lead to</span>
<span class="sd">        efficiency lost with long work arrays as input parameters for</span>
<span class="sd">        Fortran code.  In Lsodi, Lsodis and Lsoibt, Solver.solve()</span>
<span class="sd">        would be applied to get the desired solution, which will</span>
<span class="sd">        direct to this function to step forward.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">itask</span> <span class="o">=</span> <span class="mi">1</span>   <span class="c"># initial status</span>
        <span class="n">istate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydoti_flag</span>

        <span class="n">solver_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="c"># Convert class-name to name of subroutine, for example Lsodi -&gt; lsodi</span>

        <span class="n">neq</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">t_next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">res</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">res_f77</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_f77</span><span class="p">)</span>
        <span class="n">adda</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;adda_</span><span class="si">%s</span><span class="s">_f77&#39;</span> <span class="o">%</span> <span class="n">solver_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">adda</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">):</span>
            <span class="n">adda</span> <span class="o">=</span> <span class="n">adda</span><span class="o">.</span><span class="n">_cpointer</span>
        <span class="n">jac</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_</span><span class="si">%s</span><span class="s">_f77&#39;</span> <span class="o">%</span> <span class="n">solver_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">jac</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">):</span>
            <span class="n">jac</span> <span class="o">=</span> <span class="n">jac</span><span class="o">.</span><span class="n">_cpointer</span>

        <span class="n">tried</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">tried</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>       <span class="c"># prevent endless loop</span>
            <span class="n">u_new</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">istate</span><span class="p">,</span> <span class="n">iwork</span> <span class="o">=</span> <span class="nb">apply</span><span class="p">(</span>\
                <span class="nb">eval</span><span class="p">(</span><span class="s">&#39;self._odepack.d</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">solver_name</span><span class="p">),</span>\
                <span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">adda</span><span class="p">,</span> <span class="n">jac</span><span class="p">,</span> <span class="n">neq</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ydoti</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t_next</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">itol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtol</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atol</span><span class="p">,</span> <span class="n">itask</span><span class="p">,</span> <span class="n">istate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lrw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">liw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mf</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_extra_args_fortran</span><span class="p">)</span>
            <span class="n">tried</span> <span class="o">+=</span> <span class="mi">1</span>
	    <span class="c"># &quot;istate&quot; indicates the returned status</span>
            <span class="k">if</span> <span class="n">istate</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># successful return status</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>       <span class="c"># Error occurs!</span>
                <span class="k">print</span> <span class="bp">self</span><span class="o">.</span><span class="n">_error_messages</span><span class="p">[</span><span class="n">istate</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">[</span><span class="mi">12</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">istate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>    <span class="c"># Increase maximum step-number.</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_stepnr</span><span class="p">(),</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">istate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>  <span class="c"># Multiply tolerance with suggested factor</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tol_multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">[</span><span class="mi">13</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">istate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">3</span><span class="p">:</span>
                    <span class="c"># Illegal input was detected,</span>
                    <span class="c"># before taking any integration steps.</span>
                    <span class="k">if</span> <span class="n">iwork</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">lrw</span><span class="p">:</span>   <span class="c"># Real work array is too short.</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">expand_rwork</span><span class="p">(</span><span class="n">iwork</span><span class="p">[</span><span class="mi">16</span><span class="p">],</span> <span class="n">expand</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">iwork</span><span class="p">[</span><span class="mi">17</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">liw</span><span class="p">:</span> <span class="c"># Integer work array is too short</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">expand_iwork</span><span class="p">(</span><span class="n">iwork</span><span class="p">[</span><span class="mi">17</span><span class="p">],</span> <span class="n">expand</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c"># Other abnormal cases with istate returned as -3</span>
                        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="c"># Interrupt</span>
                <span class="k">elif</span> <span class="n">istate</span> <span class="o">==</span> <span class="o">-</span><span class="mi">6</span><span class="p">:</span>
                    <span class="c"># divide-zero-error when error(i) became 0 for some i</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">adjust_atol</span><span class="p">(</span><span class="n">u_new</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>   <span class="c"># Unavoidable interrupts</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c">#  Interrupt</span>
                <span class="n">istate</span> <span class="o">=</span> <span class="mi">1</span>
	<span class="k">return</span> <span class="n">u_new</span>

<span class="c">### end of class Odepack ###</span>
</div></div>
<div class="viewcode-block" id="Lsode"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsode">[docs]</a><span class="k">class</span> <span class="nc">Lsode</span><span class="p">(</span><span class="n">Odepack</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    A Python wrapper of the LSODE (Livermore Solver for Ordinary</span>
<span class="sd">    Differential Equations) FORTRAN subroutine.  Basic Solver in</span>
<span class="sd">    ODEPACK package from netib.  Solves the initial-value problem for</span>
<span class="sd">    stiff or nonstiff systems of first-order ODE, :math:`u&#39; = f(u,t)`</span>
<span class="sd">    via Adams or BDF methods (for the nonstiff and stiff cases,</span>
<span class="sd">    respectively).  Can generate the Jacobian, or apply a</span>
<span class="sd">    user-supplied Jacobian in dense or banded format.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">quick_description</span> <span class="o">=</span> <span class="s">&quot;LSODE solver for a stiff or nonstiff system&quot;</span>

    <span class="n">_optional_parameters</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_optional_parameters</span> <span class="o">+</span> \
        <span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">,</span> <span class="s">&#39;jac_banded_f77&#39;</span><span class="p">,</span> <span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span><span class="p">,</span> <span class="s">&#39;jac&#39;</span><span class="p">,</span> <span class="s">&#39;jac_f77&#39;</span><span class="p">,</span> <span class="s">&#39;order&#39;</span><span class="p">,</span>
         <span class="s">&#39;f_f77&#39;</span><span class="p">]</span>

    <span class="n">_iwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_iwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span>
    <span class="n">_rwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_rwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_extra_args_fortran</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="Lsode.adjust_parameters"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsode.adjust_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Properties for new parameters in this solver.&quot;&quot;&quot;</span>
       <span class="c"># If jac_banded is input in form of jac(u,t,ml,mu),</span>
        <span class="c"># wrap jac_banded to jac_banded_f77 for Fortran code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;array_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Fortran&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac_banded_f77&#39;</span>
        <span class="c"># If jac_banded is input in form of jac(t,u,ml,mu),</span>
        <span class="c"># wrap jac_banded_f77 to the general form jac_banded(u,t,ml,mu)</span>
        <span class="c"># for switch_to().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac_banded&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;condition-list&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">{</span><span class="s">&#39;1&#39;</span><span class="p">:[(</span><span class="s">&#39;jac&#39;</span><span class="p">,</span><span class="s">&#39;jac_f77&#39;</span><span class="p">),],</span>\
                 <span class="s">&#39;4&#39;</span><span class="p">:[</span><span class="s">&#39;ml&#39;</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">,(</span><span class="s">&#39;jac_banded&#39;</span><span class="p">,</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">)],</span>\
                 <span class="s">&#39;5&#39;</span><span class="p">:(</span><span class="s">&#39;ml&#39;</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;help&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">Corrector iteration method choice with 6 possible</span>
<span class="s">values:</span>

<span class="s">  0. Functional iteration without any Jacobian</span>
<span class="s">     matrix involved.</span>
<span class="s">  1. Chord iteration with user-supplied full</span>
<span class="s">     Jacobian.</span>
<span class="s">  2. Chord iteration with internally generated</span>
<span class="s">     full Jacobian matrix.</span>
<span class="s">  3. Chord iteration with internally generated</span>
<span class="s">     diagonal Jacobian matrix.</span>
<span class="s">  4. Chord iteration with user-supplied banded</span>
<span class="s">     Jacobian matrix.</span>
<span class="s">  5. Chord iteration with internally generated</span>
<span class="s">     banded Jacobian matrix.&quot;&quot;&quot;</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsode.set_extra_args"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsode.set_extra_args">[docs]</a>    <span class="k">def</span> <span class="nf">set_extra_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="c"># ml &amp; mu are required to be extra parameters for banded Jacobian.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ml&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jac_f77</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_extra_args_fortran</span> <span class="p">[</span><span class="s">&#39;jac_extra_args&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ml</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">set_extra_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsode.set_iter_method"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsode.set_iter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_iter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">):</span>
            <span class="n">with_ml_mu</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;ml&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span><span class="p">)</span>
            <span class="n">with_jac_banded</span> <span class="o">=</span> \
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_banded&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_banded_f77&#39;</span><span class="p">)</span>
            <span class="n">with_jac_full</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_f77&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">with_ml_mu</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">4</span> <span class="k">if</span> <span class="n">with_jac_banded</span> <span class="k">else</span> <span class="mi">5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">with_jac_full</span> <span class="k">else</span> <span class="mi">2</span>
</div>
<div class="viewcode-block" id="Lsode.set_jac"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsode.set_jac">[docs]</a>    <span class="k">def</span> <span class="nf">set_jac</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="ow">is</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jac_f77</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jac_banded_f77</span>
</div>
<div class="viewcode-block" id="Lsode.set_liw_min"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsode.set_liw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_liw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">liw_min</span> <span class="o">=</span> <span class="mi">20</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,)</span> <span class="k">else</span> <span class="mi">20</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span>
</div>
<div class="viewcode-block" id="Lsode.set_lrw_min"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsode.set_lrw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_lrw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mf_length</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">:(</span><span class="mi">20</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">11</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">12</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">13</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>\
                     <span class="mi">14</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">15</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">20</span><span class="p">:(</span><span class="mi">20</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">21</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>\
                     <span class="mi">22</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">23</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">24</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mi">25</span><span class="p">:(</span><span class="mi">22</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">)}</span>
        <span class="n">lrw_arg</span> <span class="o">=</span> <span class="n">mf_length</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mf</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="n">lrw_arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="n">lrw_arg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">lrw_arg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mf</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">24</span><span class="p">,</span><span class="mi">25</span><span class="p">):</span>  <span class="c"># user-supplied banded Jacobian matrics</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ml</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span>
</div>
<div class="viewcode-block" id="Lsode.set_iopt"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsode.set_iopt">[docs]</a>    <span class="k">def</span> <span class="nf">set_iopt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> \
                            <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork_in</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>


<span class="c">### End of Lsode ###</span>

</div></div>
<div class="viewcode-block" id="Lsoda"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoda">[docs]</a><span class="k">class</span> <span class="nc">Lsoda</span><span class="p">(</span><span class="n">Odepack</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    A Python wrapper of the LSODA FORTRAN subroutine from ODEPACK.</span>
<span class="sd">    This subroutine automatically shifts between stiff (BDF) and</span>
<span class="sd">    nonstiff (Adams) methods, such that the user does not need to</span>
<span class="sd">    determine whether the problem is stiff or not (as is the case when</span>
<span class="sd">    using the LSODE subroutine and class :class:`Lsode`). The</span>
<span class="sd">    integration always starts with the nonstiff method.  Can generate</span>
<span class="sd">    the Jacobian, or apply a user-supplied Jacobian in dense or banded</span>
<span class="sd">    format.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">quick_description</span> <span class="o">=</span><span class="s">&quot;LSODA solver with stiff-nonstiff auto shift&quot;</span>

    <span class="n">_optional_parameters</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_optional_parameters</span> <span class="o">+</span> \
        <span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">,</span> <span class="s">&#39;jac_banded_f77&#39;</span><span class="p">,</span> <span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span><span class="p">,</span> <span class="s">&#39;jac&#39;</span><span class="p">,</span> <span class="s">&#39;jac_f77&#39;</span><span class="p">,</span>
         <span class="s">&#39;max_ordn&#39;</span><span class="p">,</span> <span class="s">&#39;max_ords&#39;</span><span class="p">,</span> <span class="s">&#39;f_f77&#39;</span><span class="p">]</span>


    <span class="n">_iwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_iwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span>
    <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;max_ordn&#39;</span><span class="p">,</span> <span class="s">&#39;max_ords&#39;</span>
    <span class="n">_rwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_rwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_error_messages</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_error_messages</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">    Length of RWORK or IWORK are too small to proceed, but the integration</span>
<span class="s">    was successful as far as &#39;&#39;&#39;</span>

<div class="viewcode-block" id="Lsoda.adjust_parameters"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoda.adjust_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Properties for new parameters in this solver.&quot;&quot;&quot;</span>
        <span class="c"># If jac_banded is input in form of jac(u,t,ml,mu),</span>
        <span class="c"># wrap jac_banded to jac_banded_f77 for Fortran code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;array_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Fortran&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac_banded_f77&#39;</span>
        <span class="c"># If jac_banded is input in form of jac(t,u,ml,mu),</span>
        <span class="c"># wrap jac_banded_f77 to the general form jac_banded(u,t,ml,mu)</span>
        <span class="c"># for switch_to().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac_banded&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;condition-list&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">{</span><span class="s">&#39;1&#39;</span><span class="p">:[(</span><span class="s">&#39;jac&#39;</span><span class="p">,</span><span class="s">&#39;jac_f77&#39;</span><span class="p">),],</span>
                 <span class="s">&#39;4&#39;</span><span class="p">:[(</span><span class="s">&#39;jac_banded&#39;</span><span class="p">,</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">),</span><span class="s">&#39;ml&#39;</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">],</span>
                 <span class="s">&#39;5&#39;</span><span class="p">:(</span><span class="s">&#39;ml&#39;</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;help&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">Jacobian type choice with 4 possible values:</span>

<span class="s"> 1. User-supplied full Jacobian matrix</span>
<span class="s"> 2. Internally generated full Jacobian (default)</span>
<span class="s"> 4. User-supplied banded Jacobian matrix</span>
<span class="s"> 5. Internally generated banded Jacobian matrix&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsoda.set_extra_args"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoda.set_extra_args">[docs]</a>    <span class="k">def</span> <span class="nf">set_extra_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="c"># ml &amp; mu are required to be extra parameters for banded Jacobian.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ml&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jac_f77</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_extra_args_fortran</span> <span class="p">[</span><span class="s">&#39;jac_extra_args&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ml</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">set_extra_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsoda.set_iter_method"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoda.set_iter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_iter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">):</span>
            <span class="n">with_ml_mu</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;ml&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span><span class="p">)</span>
            <span class="n">with_jac_banded</span> <span class="o">=</span> \
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_banded&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_banded_f77&#39;</span><span class="p">)</span>
            <span class="n">with_jac_full</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_f77&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">with_ml_mu</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">4</span> <span class="k">if</span> <span class="n">with_jac_banded</span> <span class="k">else</span> <span class="mi">5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">with_jac_full</span> <span class="k">else</span> <span class="mi">2</span>
</div>
<div class="viewcode-block" id="Lsoda.set_jac"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoda.set_jac">[docs]</a>    <span class="k">def</span> <span class="nf">set_jac</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="ow">is</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jac_f77</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jac_banded_f77</span>
</div>
<div class="viewcode-block" id="Lsoda.set_liw_min"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoda.set_liw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_liw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">liw_min</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span>
</div>
<div class="viewcode-block" id="Lsoda.set_lrw_min"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoda.set_lrw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_lrw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">+</span> <span class="mi">16</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span><span class="p">,</span> <span class="mi">22</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span><span class="p">,</span> \
                           <span class="mi">22</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span> <span class="o">+</span> \
                           <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ml</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Lsoda.set_iopt"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoda.set_iopt">[docs]</a>    <span class="k">def</span> <span class="nf">set_iopt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork_in</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">))</span>

<span class="c">### End of Lsoda ###</span>
</div></div>
<div class="viewcode-block" id="Lsodar"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodar">[docs]</a><span class="k">class</span> <span class="nc">Lsodar</span><span class="p">(</span><span class="n">Odepack</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>

<span class="sd">    A Python wrapper of the LSODAR subroutine in ODEPACK.</span>
<span class="sd">    LSODAR is a variant of LSODE and differs from the latter in</span>
<span class="sd">    two ways.</span>

<span class="sd">    Quote from the LSODAR source code documentation:</span>
<span class="sd">    &quot;(a) It switches automatically between stiff and nonstiff methods.</span>
<span class="sd">    This means that the user does not have to determine whether the</span>
<span class="sd">    problem is stiff or not, and the solver will automatically choose the</span>
<span class="sd">    appropriate method.  It always starts with the nonstiff method.</span>
<span class="sd">    (b) It finds the root of at least one of a set of constraint</span>
<span class="sd">    functions g(i) of the independent and dependent variables.</span>
<span class="sd">    It finds only those roots for which some g(i), as a function</span>
<span class="sd">    of t, changes sign in the interval of integration.</span>
<span class="sd">    It then returns the solution at the root, if that occurs</span>
<span class="sd">    sooner than the specified stop condition, and otherwise returns</span>
<span class="sd">    the solution according the specified stop condition.&quot;</span>

<span class="sd">    The mathematical problem reads</span>

<span class="sd">    ..:math::</span>
<span class="sd">               u&#39; &amp;= f(u, t),</span>
<span class="sd">          g(u,t)  &amp;= 0.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">quick_description</span> <span class="o">=</span> <span class="s">&quot;LSODAR method with stiff-nonstiff auto shift&quot;</span>

    <span class="n">_optional_parameters</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_optional_parameters</span> <span class="o">+</span> \
        <span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">,</span> <span class="s">&#39;jac_banded_f77&#39;</span><span class="p">,</span> <span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span><span class="p">,</span> <span class="s">&#39;jac&#39;</span><span class="p">,</span> <span class="s">&#39;jac_f77&#39;</span><span class="p">,</span>
         <span class="s">&#39;max_ordn&#39;</span><span class="p">,</span> <span class="s">&#39;max_ords&#39;</span><span class="p">,</span> <span class="s">&#39;g&#39;</span><span class="p">,</span> <span class="s">&#39;g_f77&#39;</span><span class="p">,</span> <span class="s">&#39;ng&#39;</span><span class="p">,</span> <span class="s">&#39;f_f77&#39;</span><span class="p">]</span>

    <span class="n">_iwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_iwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span>
    <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;max_ordn&#39;</span><span class="p">,</span> <span class="s">&#39;max_ords&#39;</span>
    <span class="n">_rwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_rwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_error_messages</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_error_messages</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">    Length of RWORK or IWORK are too small to proceed, but the integration</span>
<span class="s">    was successful as far as &#39;&#39;&#39;</span>

<div class="viewcode-block" id="Lsodar.adjust_parameters"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodar.adjust_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Properties for new parameters in this solver.&quot;&quot;&quot;</span>
        <span class="c"># If jac_banded is input in form of jac(u,t,ml,mu),</span>
        <span class="c"># wrap jac_banded to jac_banded_f77 for Fortran code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;array_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Fortran&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac_banded_f77&#39;</span>
        <span class="c"># If jac_banded is input in form of jac(t,u,ml,mu),</span>
        <span class="c"># wrap jac_banded_f77 to the general form jac_banded(u,t,ml,mu)</span>
        <span class="c"># for switch_to().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t,ml,mu&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac_banded&#39;</span>

        <span class="c"># If g is input in form of g(u,t),</span>
        <span class="c"># wrap g to g_f77 for Fortran code.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;g&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;g&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;g&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;g_f77&#39;</span>
        <span class="c"># If g is input in form of g(t,u),</span>
        <span class="c"># wrap g_f77 to the general form g(u,t) for switch_to().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;g_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;g_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;g_f77&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;g&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;condition-list&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">{</span><span class="s">&#39;1&#39;</span><span class="p">:[(</span><span class="s">&#39;jac&#39;</span><span class="p">,</span><span class="s">&#39;jac_f77&#39;</span><span class="p">),],</span>
                 <span class="s">&#39;4&#39;</span><span class="p">:[(</span><span class="s">&#39;jac_banded&#39;</span><span class="p">,</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">),</span><span class="s">&#39;ml&#39;</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">],</span>
                 <span class="s">&#39;5&#39;</span><span class="p">:(</span><span class="s">&#39;ml&#39;</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;help&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">Jacobian type choice with 4 possible values:</span>

<span class="s">1. User-supplied full Jacobian matrix</span>
<span class="s">2. Internally generated full Jacobian (default)</span>
<span class="s">4. User-supplied banded Jacobian matrix</span>
<span class="s">5. Internally generated banded Jacobian matrix&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Lsodar.set_extra_args"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodar.set_extra_args">[docs]</a>    <span class="k">def</span> <span class="nf">set_extra_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="c"># ml &amp; mu are required to be extra parameters for banded Jacobian.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ml&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">==</span> <span class="mi">4</span> <span class="ow">and</span> \
                    <span class="p">(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jac_f77</span><span class="p">,</span> <span class="s">&#39;_cpointer&#39;</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_extra_args_fortran</span> <span class="p">[</span><span class="s">&#39;jac_extra_args&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ml</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">set_extra_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodar.set_iter_method"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodar.set_iter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_iter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">):</span>
            <span class="n">with_ml_mu</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;ml&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span><span class="p">)</span>
            <span class="n">with_jac_banded</span> <span class="o">=</span> \
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_banded&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_banded_f77&#39;</span><span class="p">)</span>
            <span class="n">with_jac_full</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_f77&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">with_ml_mu</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">4</span> <span class="k">if</span> <span class="n">with_jac_banded</span> <span class="k">else</span> <span class="mi">5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">with_jac_full</span> <span class="k">else</span> <span class="mi">2</span>
</div>
<div class="viewcode-block" id="Lsodar.set_jac"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodar.set_jac">[docs]</a>    <span class="k">def</span> <span class="nf">set_jac</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;jac_banded_f77&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="ow">is</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jac_f77</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jac_banded_f77</span>
</div>
<div class="viewcode-block" id="Lsodar.set_liw_min"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodar.set_liw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_liw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">liw_min</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span>
</div>
<div class="viewcode-block" id="Lsodar.set_lrw_min"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodar.set_lrw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_lrw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">+</span> <span class="mi">16</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ng</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span><span class="p">,</span> <span class="mi">22</span> <span class="o">+</span> <span class="mi">9</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> \
                           <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ng</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span><span class="p">,</span> \
                           <span class="mi">22</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ng</span> <span class="o">+</span> \
                           <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ml</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Lsodar.set_iopt"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodar.set_iopt">[docs]</a>    <span class="k">def</span> <span class="nf">set_iopt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork_in</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Lsodar.solve"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodar.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_points</span><span class="p">,</span> <span class="n">terminate</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># ng is numbers of constraint-functions</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;g&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">U0</span><span class="p">,</span><span class="n">time_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">size</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;g_f77&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g_f77</span><span class="p">,</span><span class="s">&#39;_cpointer&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">g</span><span class="p">(</span><span class="n">time_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">U0</span><span class="p">))</span><span class="o">.</span><span class="n">size</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ng&#39;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">        Unsufficient input! ng must be specified if g is input as a</span>
<span class="s">        Fortran subroutine. &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">time_points</span><span class="p">,</span> <span class="n">terminate</span><span class="o">=</span><span class="n">terminate</span><span class="p">)</span>

<span class="c">### End of Lsodar ###</span>
</div></div>
<div class="viewcode-block" id="Lsodes"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodes">[docs]</a><span class="k">class</span> <span class="nc">Lsodes</span><span class="p">(</span><span class="n">Odepack</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Python wrapper of the LSODES subroutine from ODEPACK.</span>
<span class="sd">    LSODES is a variant of LSODE intended for problems where the</span>
<span class="sd">    Jacobian is provided via a sparse matrix data structure</span>
<span class="sd">    consisting of the parameters ``jac_column``, ``ia``, ``ja``,</span>
<span class="sd">    and optionally ``jac_column_f77``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">quick_description</span> <span class="o">=</span> <span class="s">&quot;LSODES solver for sparse Jacobians&quot;</span>

    <span class="n">_optional_parameters</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_optional_parameters</span> <span class="o">+</span> \
        <span class="p">[</span><span class="s">&#39;order&#39;</span><span class="p">,</span> <span class="s">&#39;moss&#39;</span><span class="p">,</span><span class="s">&#39;seth&#39;</span><span class="p">,</span> <span class="s">&#39;jac_column&#39;</span><span class="p">,</span> <span class="s">&#39;ia&#39;</span><span class="p">,</span> <span class="s">&#39;ja&#39;</span><span class="p">,</span> <span class="s">&#39;jac_column_f77&#39;</span><span class="p">,</span>
         <span class="s">&#39;f_f77&#39;</span><span class="p">]</span>

    <span class="n">_extra_args_fortran</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_error_messages</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_error_messages</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    A fatal error return flag came from the sparse solver CDRV by way of DPRJS</span>
<span class="s">    or DSOLSS (numerical factorization or backsolve).  This should never happen.</span>
<span class="s">    The integration was successful as far as &#39;&#39;&#39;</span>


<div class="viewcode-block" id="Lsodes.adjust_parameters"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodes.adjust_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Properties for new parameters in this solver.&quot;&quot;&quot;</span>
        <span class="c"># If jac_column is input in form of jac(u,t,j),</span>
        <span class="c"># wrap jac_column to jac_column_f77(t,u,j-1) for Fortran code.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_column&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t,j-1,ia,ja&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_column&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u,j,ia,ja&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_column&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac_column_f77&#39;</span>
        <span class="c"># If jac_column is input in form of jac(t,u,j),</span>
        <span class="c"># wrap it to the general form jac_column(u,t,j) for switch_to().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_column_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_old&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;t,u,j+1&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_column_f77&#39;</span><span class="p">][</span><span class="s">&#39;paralist_new&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;u,t,j&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;jac_column_f77&#39;</span><span class="p">][</span><span class="s">&#39;name_wrapped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;jac_column&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;moss&#39;</span><span class="p">][</span><span class="s">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;moss&#39;</span><span class="p">][</span><span class="s">&#39;condition-list&#39;</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[(</span><span class="s">&#39;jac_column&#39;</span><span class="p">,</span> <span class="s">&#39;jac_column_f77&#39;</span><span class="p">),],</span> \
                         <span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="s">&#39;ia&#39;</span><span class="p">,</span> <span class="s">&#39;ja&#39;</span><span class="p">]}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;moss&#39;</span><span class="p">][</span><span class="s">&#39;help&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">Method choice to obtain sparse structure with 3 possible</span>
<span class="s">values:</span>

<span class="s">  0. The user has supplied IA, JA.</span>
<span class="s">  1  The user has supplied JAC_COLUMN and the</span>
<span class="s">     sparse structure will be obtained from NEQ initial</span>
<span class="s">     calls to JAC_COLUMN.</span>
<span class="s">  2. The sparse structure will be obtained from</span>
<span class="s">      NEQ+1 initial calls to F.&quot;&quot;&quot;</span><span class="p">,</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;condition-list&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">{</span><span class="s">&#39;1&#39;</span><span class="p">:[(</span><span class="s">&#39;jac_column&#39;</span><span class="p">,</span><span class="s">&#39;jac_column_f77&#39;</span><span class="p">),],}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;help&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">Corrector iteration method choice with 4</span>
<span class="s">possible values:</span>

<span class="s"> 0. Functional iteration without any Jacobian</span>
<span class="s">    matrix.</span>
<span class="s"> 1. Chord iteration with user-supplied sparse</span>
<span class="s">    Jacobian.</span>
<span class="s"> 2. Chord iteration with internally generated</span>
<span class="s">    sparse Jacobian matrix.</span>
<span class="s"> 3. Chord iteration with internally generated</span>
<span class="s">    diagonal Jacobian matrix.&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodes.set_iter_method"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodes.set_iter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_iter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">with_jac_column</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;jac_column&#39;</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;jac_column_f77&#39;</span><span class="p">)</span>
        <span class="n">with_ia_ja</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ia&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ja&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;moss&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">with_ia_ja</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moss</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">with_jac_column</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moss</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moss</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">with_jac_column</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodes.set_iwork_rwork"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodes.set_iwork_rwork">[docs]</a>    <span class="k">def</span> <span class="nf">set_iwork_rwork</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialization of work arrays with caculated length and optional inputs.</span>
<span class="sd">        In ODEPACK, &quot;iwork&quot; &amp; &quot;rwork&quot; should be initialized with the specific</span>
<span class="sd">        optional parameters in all the solvers.</span>
<span class="sd">        &quot;liw&quot; &amp; &quot;lrw&quot; represented the length requirement of work arrays.</span>
<span class="sd">        Specially, in Dlsodes, ia &amp; ja should be attached to iwork_in.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c"># initialize integer work array (iwork)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">30</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moss</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ia&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ia</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ja</span><span class="p">)</span>
        <span class="n">nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ja&#39;</span><span class="p">,[]))</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ja&#39;</span><span class="p">)</span> \
                      <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>  <span class="c"># default value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">liw_min</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_iwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span>

        <span class="c"># calculate the minimum length of float work array (rwork)</span>
        <span class="n">maxord</span> <span class="o">=</span> <span class="mi">5</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adams_or_bdf</span> <span class="o">==</span> <span class="s">&quot;bdf&quot;</span> <span class="k">else</span> <span class="mi">12</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="p">(</span><span class="n">maxord</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">lrw_arg</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">9</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">),(</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>\
                  <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">+=</span> <span class="n">lrw_arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">nnz</span><span class="o">*</span><span class="n">lrw_arg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="n">lrw_arg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span>\
                  <span class="p">((</span><span class="n">nnz</span> <span class="o">+</span> <span class="n">lrw_arg</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>

        <span class="c"># Initializereal input work arrays</span>
        <span class="n">lrw_in</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rwork_index</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rwork_in</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">lrw_in</span><span class="p">,</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rwork_in</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_rwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="mf">0.</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodes.set_iopt"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodes.set_iopt">[docs]</a>    <span class="k">def</span> <span class="nf">set_iopt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork_in</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork_in</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">))</span>

<span class="c">### End of Lsodes ###</span>

</div></div>
<div class="viewcode-block" id="Lsodi"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodi">[docs]</a><span class="k">class</span> <span class="nc">Lsodi</span><span class="p">(</span><span class="n">Odepack</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A Python wrapper of the LSODI subroutine from ODEPACK, targeting</span>
<span class="sd">    ODE problems of the form</span>

<span class="sd">    .. math::</span>
<span class="sd">               A(u,t) u&#39; &amp; = g(u,t)</span>

<span class="sd">    where :math:`A(u,t)` is a square matrix and :math:`g` some function.</span>
<span class="sd">    If :math:`A` is singular, this is a differential-algebraic system.</span>
<span class="sd">    The user input is in the form of a residual function</span>
<span class="sd">    :math:`r = g - As` for some vector :math:`s`. The residual :math:`r`</span>
<span class="sd">    is provided by the user function ``res`` (Python) or ``res_f77``</span>
<span class="sd">    (FORTRAN).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">quick_description</span> <span class="o">=</span> <span class="s">&quot;LSODI solver for linearly implicit systems&quot;</span>

    <span class="n">_optional_parameters</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_optional_parameters</span> <span class="o">+</span> \
        <span class="p">[</span><span class="s">&#39;adda_lsodi&#39;</span><span class="p">,</span> <span class="s">&#39;adda_banded_lsodi&#39;</span><span class="p">,</span> <span class="s">&#39;adda_lsodi_f77&#39;</span><span class="p">,</span>
         <span class="s">&#39;adda_banded_lsodi_f77&#39;</span><span class="p">,</span> <span class="s">&#39;jac_lsodi&#39;</span><span class="p">,</span> <span class="s">&#39;jac_banded_lsodi&#39;</span><span class="p">,</span>
         <span class="s">&#39;jac_lsodi_f77&#39;</span><span class="p">,</span> <span class="s">&#39;jac_banded_lsodi_f77&#39;</span><span class="p">,</span> <span class="s">&#39;res&#39;</span><span class="p">,</span>
         <span class="s">&#39;order&#39;</span><span class="p">,</span> <span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span><span class="p">,</span> <span class="s">&#39;ydoti&#39;</span><span class="p">,</span> <span class="s">&#39;nsteps&#39;</span><span class="p">,</span> <span class="s">&#39;res_f77&#39;</span><span class="p">]</span>

    <span class="n">_required_parameters</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">_iwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_iwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;ml&#39;</span><span class="p">,</span> <span class="s">&#39;mu&#39;</span>
    <span class="n">_rwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_rwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_extra_args_fortran</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_error_messages</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_error_messages</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    User-supplied Subroutine RES set its error flag (IRES = 3) despite repeated</span>
<span class="s">    tries by Lsodi to avoid that condition. Current T is &#39;&#39;&#39;</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    Lsodi was unable to compute the initial value of du/dt.</span>
<span class="s">    Current T is &#39;&#39;&#39;</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    User-supplied Subroutine RES signalled Lsodi to halt the</span>
<span class="s">    integration and return (IRES = 2). Current T is &#39;&#39;&#39;</span>

<div class="viewcode-block" id="Lsodi.__init__"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodi.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c"># Different default setting of iteration methods</span>
        <span class="n">with_jac</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;jac_lsodi&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s">&#39;jac_lsodi_f77&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> \
            <span class="ow">or</span> <span class="p">(</span><span class="s">&#39;jac_banded_lsodi&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="s">&#39;jac_banded_lsodi_f77&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;adams_or_bdf&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;adams_or_bdf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;adams&#39;</span> <span class="k">if</span> <span class="n">with_jac</span> <span class="k">else</span> <span class="s">&#39;bdf&#39;</span>
        <span class="c"># &#39;f&#39; is not a mandatory parameter in Lsodi()</span>
        <span class="c"># set f with dummy definition for general constructor</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodi.adjust_parameters"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodi.adjust_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;condition-list&#39;</span><span class="p">]</span> <span class="o">=</span> \
                         <span class="p">{</span><span class="s">&#39;1&#39;</span><span class="p">:[(</span><span class="s">&#39;jac_lsodi&#39;</span><span class="p">,</span><span class="s">&#39;jac_lsodi_f77&#39;</span><span class="p">),</span>
                               <span class="p">(</span><span class="s">&#39;adda_lsodi&#39;</span><span class="p">,</span><span class="s">&#39;adda_lsodi_f77&#39;</span><span class="p">),</span>
                               <span class="p">(</span><span class="s">&#39;res&#39;</span><span class="p">,</span> <span class="s">&#39;res_f77&#39;</span><span class="p">)],</span>
                          <span class="s">&#39;2&#39;</span><span class="p">:[(</span><span class="s">&#39;adda_lsodi&#39;</span><span class="p">,</span><span class="s">&#39;adda_lsodi_f77&#39;</span><span class="p">),</span>
                               <span class="p">(</span><span class="s">&#39;res&#39;</span><span class="p">,</span> <span class="s">&#39;res_f77&#39;</span><span class="p">)],</span>\
                          <span class="s">&#39;4&#39;</span><span class="p">:[</span><span class="s">&#39;ml&#39;</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;res&#39;</span><span class="p">,</span> <span class="s">&#39;res_f77&#39;</span><span class="p">),</span>
                               <span class="p">(</span><span class="s">&#39;adda_banded_lsodi&#39;</span><span class="p">,</span><span class="s">&#39;adda_banded_lsodi_f77&#39;</span><span class="p">),</span>
                               <span class="p">(</span><span class="s">&#39;jac_banded_lsodi&#39;</span><span class="p">,</span><span class="s">&#39;jac_banded_lsodi_f77&#39;</span><span class="p">)],</span>\
                          <span class="s">&#39;5&#39;</span><span class="p">:[</span><span class="s">&#39;ml&#39;</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;res&#39;</span><span class="p">,</span> <span class="s">&#39;res_f77&#39;</span><span class="p">),</span>
                               <span class="p">(</span><span class="s">&#39;adda_banded_lsodi&#39;</span><span class="p">,</span><span class="s">&#39;adda_banded_lsodi_f77&#39;</span><span class="p">)]</span> <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;help&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">Choice for the corrector iteration method:</span>

<span class="s">  1. Chord iteration with a user-supplied full</span>
<span class="s">     Jacobian matrix.</span>
<span class="s">  2. Chord iteration with an internally generated</span>
<span class="s">     (difference quotient) full Jacobian. This</span>
<span class="s">     uses neq+1 extra calls to res per dr/du</span>
<span class="s">     evaluation.(Default)</span>
<span class="s">  4. Chord iteration with a user-supplied banded</span>
<span class="s">     Jacobian matrix.</span>
<span class="s">  5. Chord iteration with an internally generated</span>
<span class="s">     banded Jacobian matrix. Using ml+mu+2</span>
<span class="s">     extra calls to res per dr/du evaluation.&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodi.set_extra_args"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodi.set_extra_args">[docs]</a>    <span class="k">def</span> <span class="nf">set_extra_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extra_args_fortran</span> <span class="p">[</span><span class="s">&#39;jac_extra_args&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ml</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extra_args_fortran</span> <span class="p">[</span><span class="s">&#39;adda_extra_args&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ml</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">set_extra_args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodi.set_iter_method"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodi.set_iter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_iter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">):</span>
            <span class="n">with_banded_jac</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;jac_banded_lsodi_f77&#39;</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;jac_banded_lsodi&#39;</span><span class="p">)</span>
            <span class="n">with_banded_adda</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;adda_banded_lsodi_f77&#39;</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;adda_banded_lsodi&#39;</span><span class="p">)</span>
            <span class="n">with_ml_mu</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ml&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">)</span>
            <span class="n">with_full_jac</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;jac_lsodi_f77&#39;</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;jac_lsodi&#39;</span><span class="p">)</span>
            <span class="n">with_full_adda</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;adda_lsodi_f77&#39;</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;adda_lsodi&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">with_ml_mu</span> <span class="ow">and</span> <span class="n">with_banded_jac</span> <span class="ow">and</span> <span class="n">with_banded_adda</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">4</span>
            <span class="k">elif</span> <span class="n">with_ml_mu</span> <span class="ow">and</span> <span class="n">with_banded_adda</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="k">elif</span> <span class="n">with_full_jac</span> <span class="ow">and</span> <span class="n">with_full_adda</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">with_full_adda</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&#39;adda must be supplied in Lsodi.&#39;</span>
</div>
<div class="viewcode-block" id="Lsodi.set_jac"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodi.set_jac">[docs]</a>    <span class="k">def</span> <span class="nf">set_jac</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jac_lsodi_f77</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jac_banded_lsodi_f77</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adda_lsodi_f77</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adda_banded_lsodi_f77</span>
</div>
<div class="viewcode-block" id="Lsodi.set_liw_min"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodi.set_liw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_liw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">liw_min</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span>
</div>
<div class="viewcode-block" id="Lsodi.set_lrw_min"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodi.set_lrw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_lrw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mf_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span><span class="mi">25</span><span class="p">]</span>
        <span class="n">length_args</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">22</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">22</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">22</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">22</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span>\
                       <span class="p">(</span><span class="mi">22</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">22</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">22</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">22</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
        <span class="n">lrw_arg</span> <span class="o">=</span> <span class="n">length_args</span><span class="p">[</span><span class="n">mf_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mf</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="n">lrw_arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="n">lrw_arg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                   <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="n">lrw_arg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> \
                   <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ml&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> \
                             <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;mu&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Lsodi.set_iwork_rwork"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodi.set_iwork_rwork">[docs]</a>    <span class="k">def</span> <span class="nf">set_iwork_rwork</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># calculate the required length of work arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_liw_min</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_lrw_min</span><span class="p">()</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">check_liwlrw</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">liw</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lrw</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="n">iwork_index</span><span class="p">,</span> <span class="n">rwork_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iwork_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rwork_index</span>
        <span class="c"># Put optional inputs into work arrays with specified indices.</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">iwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">iwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">rwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="mf">0.</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodi.set_iopt"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodi.set_iopt">[docs]</a>    <span class="k">def</span> <span class="nf">set_iopt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Lsodi.set_dummy_functions"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodi.set_dummy_functions">[docs]</a>    <span class="k">def</span> <span class="nf">set_dummy_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;adda_lsodi_f77&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adda_lsodi_f77</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="mf">0.</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_lsodi_f77&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jac_lsodi_f77</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:</span> <span class="mf">0.</span>
</div>
<div class="viewcode-block" id="Lsodi.solve"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodi.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_points</span><span class="p">,</span> <span class="n">terminate</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># Call Solver.solve(), which will direct to Odepack.advance()</span>
        <span class="c"># to step forward.</span>
        <span class="k">return</span> <span class="n">Solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_points</span><span class="p">,</span> <span class="n">terminate</span><span class="o">=</span><span class="n">terminate</span><span class="p">)</span>


<span class="c">### End of Lsodi ###</span>
</div></div>
<div class="viewcode-block" id="Lsodis"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodis">[docs]</a><span class="k">class</span> <span class="nc">Lsodis</span><span class="p">(</span><span class="n">Odepack</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A Python wrapper of the LSODIS subroutine from ODEPACK.</span>
<span class="sd">    This subroutine is a variant of LSODI, intended for stiff problems</span>
<span class="sd">    in which the matrix A and the Jacobian of the residual wrt the</span>
<span class="sd">    unknown functions have a sparse structure.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">quick_description</span> <span class="o">=</span> <span class="s">&quot;LSODIS solver for linearly implicit sparse systems&quot;</span>

    <span class="n">_optional_parameters</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_optional_parameters</span> <span class="o">+</span> \
        <span class="p">[</span><span class="s">&#39;jac_lsodis&#39;</span><span class="p">,</span> <span class="s">&#39;moss&#39;</span><span class="p">,</span> <span class="s">&#39;ia&#39;</span><span class="p">,</span> <span class="s">&#39;ja&#39;</span><span class="p">,</span> <span class="s">&#39;ic&#39;</span><span class="p">,</span> <span class="s">&#39;jc&#39;</span><span class="p">,</span>
         <span class="s">&#39;ydoti&#39;</span><span class="p">,</span> <span class="s">&#39;order&#39;</span><span class="p">]</span>

    <span class="n">_required_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;res&#39;</span><span class="p">,</span> <span class="s">&#39;adda_lsodis&#39;</span><span class="p">]</span>
    <span class="c"># Do not support Fortran subroutines</span>

    <span class="n">_extra_args_fortran</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_error_messages</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_error_messages</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    User-supplied Subroutine RES set its error flag (IRES = 3) despite repeated</span>
<span class="s">    tries by Lsodis to avoid that condition. Current T is &#39;&#39;&#39;</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    Lsodis was unable to compute the initial value of du/dt.</span>
<span class="s">    Current T is &#39;&#39;&#39;</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">9</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    A fatal error return-flag came from the sparse solver CDRV.</span>
<span class="s">    This should never happen. Current T is &#39;&#39;&#39;</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    User-supplied Subroutine RES signalled Lsodis to halt the</span>
<span class="s">    integration and return (IRES = 2). Current T is &#39;&#39;&#39;</span>

<div class="viewcode-block" id="Lsodis.__init__"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodis.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c"># Different default setting of iteration methods</span>
        <span class="n">with_jac</span> <span class="o">=</span> <span class="s">&#39;jac_lsodis&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span>
        <span class="k">if</span> <span class="s">&#39;adams_or_bdf&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;adams_or_bdf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;adams&#39;</span> <span class="k">if</span> <span class="n">with_jac</span> <span class="k">else</span> <span class="s">&#39;bdf&#39;</span>
        <span class="c"># &#39;f&#39; is not a mandatory parameter in Lsodis()</span>
        <span class="c"># set f with dummy definition for general constructor</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodis.adjust_parameters"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodis.adjust_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;condition-list&#39;</span><span class="p">]</span> <span class="o">=</span> \
                         <span class="p">{</span><span class="s">&#39;1&#39;</span><span class="p">:[</span><span class="s">&#39;jac_lsodis&#39;</span><span class="p">,],}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;help&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">Choice for the corrector iteration method:</span>

<span class="s">  1. Chord iteration with a user-supplied sparse</span>
<span class="s">     Jacobian matrix.</span>
<span class="s">  2. Chord iteration with an internally generated</span>
<span class="s">     (difference quotient) sparse Jacobian matrix.</span>
<span class="s">     This uses extra calls to &quot;res&quot; per dr/du</span>
<span class="s">     evaluation. (Default)&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;moss&#39;</span><span class="p">][</span><span class="s">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;moss&#39;</span><span class="p">][</span><span class="s">&#39;condition-list&#39;</span><span class="p">]</span> <span class="o">=</span> \
                         <span class="p">{</span><span class="s">&#39;1&#39;</span><span class="p">:[</span><span class="s">&#39;jac_lsodis&#39;</span><span class="p">,],</span>
                          <span class="s">&#39;0&#39;</span><span class="p">:[</span><span class="s">&#39;ia&#39;</span><span class="p">,</span><span class="s">&#39;ja&#39;</span><span class="p">,</span><span class="s">&#39;ic&#39;</span><span class="p">,</span><span class="s">&#39;jc&#39;</span><span class="p">],</span>
                          <span class="s">&#39;3&#39;</span><span class="p">:[</span><span class="s">&#39;jac_lsodis&#39;</span><span class="p">,</span><span class="s">&#39;ia&#39;</span><span class="p">,</span><span class="s">&#39;ja&#39;</span><span class="p">],</span>
                          <span class="s">&#39;4&#39;</span><span class="p">:[</span><span class="s">&#39;ia&#39;</span><span class="p">,</span><span class="s">&#39;ja&#39;</span><span class="p">]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;moss&#39;</span><span class="p">][</span><span class="s">&#39;help&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">Method to obtain sparse structure of Jacobian matrix.</span>
<span class="s">moss has 5 possible values:</span>

<span class="s"> 0. The user has supplied IA, JA, IC, and JC.</span>
<span class="s"> 1. The user has supplied JAC and the</span>
<span class="s">    structure will be obtained from NEQ initial</span>
<span class="s">    calls to JAC and NEQ initial calls to ADDA.</span>
<span class="s"> 2. The structure will be obtained from NEQ+1</span>
<span class="s">    initial calls to RES and NEQ initial calls to ADDA.</span>
<span class="s"> 3. like MOSS = 1, except user has supplied IA and JA.</span>
<span class="s"> 4. like MOSS = 2, except user has supplied IA and JA&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodis.set_iter_method"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodis.set_iter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_iter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">with_jac</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_lsodis&#39;</span><span class="p">)</span>
        <span class="n">with_ia_ja</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;ia&#39;</span><span class="p">)</span> <span class="ow">and</span>  <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;ja&#39;</span><span class="p">)</span>
        <span class="n">with_ic_jc</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;ic&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jc&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;corrector_iter_method&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">with_jac</span> <span class="k">else</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;moss&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">with_ia_ja</span> <span class="ow">and</span> <span class="n">with_ic_jc</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moss</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">with_ia_ja</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moss</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="n">with_jac</span> <span class="k">else</span> <span class="mi">4</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">moss</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">with_jac</span> <span class="k">else</span> <span class="mi">2</span>
</div>
<div class="viewcode-block" id="Lsodis.set_iwork_rwork"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodis.set_iwork_rwork">[docs]</a>    <span class="k">def</span> <span class="nf">set_iwork_rwork</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialization of work arrays with caculated length and optional inputs.</span>
<span class="sd">        In ODEPACK, &quot;iwork&quot; &amp; &quot;rwork&quot; should be initialized with the specific</span>
<span class="sd">        optional parameters in all the solvers.</span>
<span class="sd">        &quot;liw&quot; &amp; &quot;lrw&quot; represented the length requirement of work arrays.</span>
<span class="sd">        Specially, in Lsodis, (ia, ja, ic &amp; jc) should be attached to</span>
<span class="sd">        iwork.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c"># initialize integer work array (iwork)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">30</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moss</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ia&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ia</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ja</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moss</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ic&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ic</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">jc</span><span class="p">)</span>
        <span class="n">nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ja&#39;</span><span class="p">,[]))</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;ja&#39;</span><span class="p">)</span> \
                      <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mi">2</span>  <span class="c"># default value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">liw_min</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">)</span>

        <span class="c"># calculate the length of  float work array (rwork)</span>
        <span class="n">mf_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">]</span>
        <span class="n">length_args</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">20</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">9</span><span class="p">),(</span><span class="mi">20</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">10</span><span class="p">),(</span><span class="mi">20</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">9</span><span class="p">),(</span><span class="mi">20</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">10</span><span class="p">)]</span>
        <span class="n">lrw_arg</span> <span class="o">=</span> <span class="n">length_args</span><span class="p">[</span><span class="n">mf_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mf</span> <span class="o">%</span> <span class="mi">100</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">nnz</span> <span class="o">+</span> <span class="n">lrw_arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="n">lrw_arg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
                       <span class="p">(</span><span class="n">nnz</span> <span class="o">+</span> <span class="n">lrw_arg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>

        <span class="c"># Check lrw&gt;lrw_min, liw&gt;liw_min if lrw/liw are specified by users</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">check_liwlrw</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">liw</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">liw_min</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">liw</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">liw_min</span><span class="p">)</span>

        <span class="c"># Read in optional inputs</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_iwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="mi">0</span><span class="p">)</span>

        <span class="c"># Initialize real work array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lrw</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_rwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span><span class="mf">0.</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodis.set_iopt"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodis.set_iopt">[docs]</a>    <span class="k">def</span> <span class="nf">set_iopt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodis.set_dummy_functions"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodis.set_dummy_functions">[docs]</a>    <span class="k">def</span> <span class="nf">set_dummy_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;jac_lsodis_f77&#39;</span><span class="p">,</span> <span class="s">&#39;adda_lsodis_f77&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">:</span><span class="mf">0.</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsodis.solve"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsodis.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_points</span><span class="p">,</span> <span class="n">terminate</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># Call Solver.solve(), which will direct to Odepack.advance()</span>
        <span class="c"># to step forward.</span>
        <span class="k">return</span> <span class="n">Solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_points</span><span class="p">,</span> <span class="n">terminate</span><span class="o">=</span><span class="n">terminate</span><span class="p">)</span>

<span class="c">### End of class Lsodis ###</span>
</div></div>
<div class="viewcode-block" id="Lsoibt"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoibt">[docs]</a><span class="k">class</span> <span class="nc">Lsoibt</span><span class="p">(</span><span class="n">Odepack</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A Python wrapper of the LSOIBT subroutine from ODEPACK.</span>
<span class="sd">    This subroutine is a variant of LSODI for the case where the</span>
<span class="sd">    matrices :math:`A`, :math:`dg/du`, and :math:`d(As)/du` are all</span>
<span class="sd">    block tridiagonal.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">quick_description</span> <span class="o">=</span> <span class="s">&quot;LSOIBIT solver for linearly implicit block tridiag systems&quot;</span>

    <span class="n">_optional_parameters</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_optional_parameters</span> <span class="o">+</span> \
        <span class="p">[</span><span class="s">&#39;jac_lsoibt&#39;</span><span class="p">,</span> <span class="s">&#39;ydoti&#39;</span><span class="p">,</span> <span class="s">&#39;order&#39;</span><span class="p">]</span>

    <span class="n">_required_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;res&#39;</span><span class="p">,</span> <span class="s">&#39;adda_lsoibt&#39;</span><span class="p">,</span> <span class="s">&#39;mb&#39;</span><span class="p">,</span> <span class="s">&#39;nb&#39;</span><span class="p">]</span>
    <span class="c"># Do not support Fortran subroutines</span>

    <span class="n">_iwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_iwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_iwork_index</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;mb&#39;</span><span class="p">,</span> <span class="s">&#39;nb&#39;</span>
    <span class="n">_rwork_index</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_rwork_index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">_extra_args_fortran</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_error_messages</span> <span class="o">=</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">_error_messages</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    User-supplied Subroutine RES set its error flag (IRES = 3) despite repeated</span>
<span class="s">    tries by Lsoibt_ODEPACK to avoid that condition. Current T is &#39;&#39;&#39;</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    Lsoibt_ODEPACK was unable to compute the initial value of du/dt.</span>
<span class="s">    Current T is &#39;&#39;&#39;</span>
    <span class="n">_error_messages</span><span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span><span class="se">\</span>
<span class="s">    User-supplied Subroutine RES signalled Lsoibt_ODEPACK to halt the</span>
<span class="s">    integration and return (IRES = 2). Current T is &#39;&#39;&#39;</span>

<div class="viewcode-block" id="Lsoibt.__init__"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoibt.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c"># Different default setting of iteration methods</span>
        <span class="n">with_jac</span> <span class="o">=</span> <span class="s">&#39;jac_lsoibt&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span>
        <span class="k">if</span> <span class="s">&#39;adams_or_bdf&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;adams_or_bdf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;adams&#39;</span> <span class="k">if</span> <span class="n">with_jac</span> <span class="k">else</span> <span class="s">&#39;bdf&#39;</span>
        <span class="c"># &#39;f&#39; is not a mandatory parameter in Lsoibt()</span>
        <span class="c"># set f with dummy definition for general constructor</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsoibt.adjust_parameters"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoibt.adjust_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;range&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;condition-list&#39;</span><span class="p">]</span> <span class="o">=</span> \
                         <span class="p">{</span><span class="s">&#39;1&#39;</span><span class="p">:(</span><span class="s">&#39;jac_lsoibt&#39;</span><span class="p">,),}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameters</span><span class="p">[</span><span class="s">&#39;corrector_iter_method&#39;</span><span class="p">][</span><span class="s">&#39;help&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s">Choice for the corrector iteration method:</span>

<span class="s">  1. Chord iteration with a user-supplied block-</span>
<span class="s">     tridiagonal Jacobian matrix.</span>
<span class="s">  2. Chord iteration with an internally generated</span>
<span class="s">     (difference quotient) block-tridiagonal</span>
<span class="s">     Jacobian matrix. This uses 3*mb+1 calls to</span>
<span class="s">     ``res`` per dr/du evaluation. (Default).&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">adjust_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsoibt.set_iter_method"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoibt.set_iter_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_iter_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">with_jac</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_lsoibt&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;corrector_iter_method&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iter_method</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">with_jac</span> <span class="k">else</span> <span class="mi">2</span>
</div>
<div class="viewcode-block" id="Lsoibt.set_liw_min"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoibt.set_liw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_liw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">liw_min</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span>
</div>
<div class="viewcode-block" id="Lsoibt.set_lrw_min"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoibt.set_lrw_min">[docs]</a>    <span class="k">def</span> <span class="nf">set_lrw_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mf_list</span> <span class="o">=</span> <span class="p">[</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">21</span><span class="p">,</span><span class="mi">22</span><span class="p">]</span>
        <span class="n">length_args</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">22</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">22</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">22</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">22</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">)]</span>
        <span class="n">lrw_arg</span> <span class="o">=</span> <span class="n">length_args</span><span class="p">[</span><span class="n">mf_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mf</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lrw_min</span> <span class="o">=</span> <span class="n">lrw_arg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="n">lrw_arg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
            <span class="mi">3</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">mb</span><span class="o">*</span><span class="n">lrw_arg</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Lsoibt.set_iwork_rwork"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoibt.set_iwork_rwork">[docs]</a>    <span class="k">def</span> <span class="nf">set_iwork_rwork</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># calculate the required length of work arrays</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_liw_min</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_lrw_min</span><span class="p">()</span>
        <span class="n">Odepack</span><span class="o">.</span><span class="n">check_liwlrw</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">liw</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lrw</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

        <span class="n">iwork_index</span><span class="p">,</span> <span class="n">rwork_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iwork_index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rwork_index</span>
        <span class="c"># Put optional inputs into work arrays with specified indices.</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">iwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">iwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">rwork_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rwork_index</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="mf">0.</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsoibt.set_iopt"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoibt.set_iopt">[docs]</a>    <span class="k">def</span> <span class="nf">set_iopt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iopt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iwork</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rwork</span><span class="p">[</span><span class="mi">4</span><span class="p">:</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Lsoibt.set_dummy_functions"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoibt.set_dummy_functions">[docs]</a>    <span class="k">def</span> <span class="nf">set_dummy_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;jac_lsoibt_f77&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jac_lsoibt_f77</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">:(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;adda_lsoibt_f77&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">adda_lsoibt_f77</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">:(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lsoibt.validate_data"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoibt.validate_data">[docs]</a>    <span class="k">def</span> <span class="nf">validate_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">Odepack</span><span class="o">.</span><span class="n">validate_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mb</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">nb</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">    The requirement for block size (mb,nb) are: mb&gt;=1, nb&gt;=4, mb*nb=neq=</span><span class="si">%d</span><span class="s">.</span>
<span class="s">    Your block size are (</span><span class="si">%d</span><span class="s">,</span><span class="si">%d</span><span class="s">). &#39;&#39;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neq</span><span class="p">,</span> <span class="n">mb</span><span class="p">,</span> <span class="n">nb</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="Lsoibt.solve"><a class="viewcode-back" href="../../odepack.html#odespy.odepack.Lsoibt.solve">[docs]</a>    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_points</span><span class="p">,</span> <span class="n">terminate</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c"># Call Solver.solve(), which will direct to Odepack.advance()</span>
        <span class="c"># to step forward.</span>
        <span class="k">return</span> <span class="n">Solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_points</span><span class="p">,</span> <span class="n">terminate</span><span class="o">=</span><span class="n">terminate</span><span class="p">)</span>

<span class="c">### end of class Lsoibt ###</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../../np-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">Odespy API 0.2 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Liwei Wang and Hans Petter Langtangen.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>